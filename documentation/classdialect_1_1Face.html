<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptagrams: dialect::Face Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptagrams
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedialect.html">dialect</a></li><li class="navelem"><a class="el" href="classdialect_1_1Face.html">Face</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdialect_1_1Face-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dialect::Face Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a single face of a 4-planar, orthogonal layout.  
 <a href="classdialect_1_1Face.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="faces_8h_source.html">faces.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dialect::Face:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face__coll__graph.png" border="0" usemap="#dialect_1_1Face_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa09b20192dffed6544a6f54c0940511f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#aa09b20192dffed6544a6f54c0940511f">Face</a> (Graph_SP &amp;G)</td></tr>
<tr class="memdesc:aa09b20192dffed6544a6f54c0940511f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard constructor.  <a href="#aa09b20192dffed6544a6f54c0940511f">More...</a><br /></td></tr>
<tr class="separator:aa09b20192dffed6544a6f54c0940511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d4b2f15dfee760312eacdf197b2caa"><td class="memItemLeft" align="right" valign="top"><a id="a29d4b2f15dfee760312eacdf197b2caa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a29d4b2f15dfee760312eacdf197b2caa">initWithEdgeSeq</a> (const std::vector&lt; IdPair &gt; &amp;edges)</td></tr>
<tr class="memdesc:a29d4b2f15dfee760312eacdf197b2caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to build the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>, based on the clockwise sequence of "edges" of which it is made up; here an "edge" is a mere IdPair. <br /></td></tr>
<tr class="separator:a29d4b2f15dfee760312eacdf197b2caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ede7719f1b3ee09a177cfd672646849"><td class="memItemLeft" align="right" valign="top"><a id="a6ede7719f1b3ee09a177cfd672646849"></a>
Nodes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a6ede7719f1b3ee09a177cfd672646849">getNodeSeq</a> (void)</td></tr>
<tr class="memdesc:a6ede7719f1b3ee09a177cfd672646849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the sequence (vector) of Nodes belonging to the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>, in clockwise order. <br /></td></tr>
<tr class="separator:a6ede7719f1b3ee09a177cfd672646849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956ce069ca32ac15c53f9ca45f22ed13"><td class="memItemLeft" align="right" valign="top"><a id="a956ce069ca32ac15c53f9ca45f22ed13"></a>
Sides&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a956ce069ca32ac15c53f9ca45f22ed13">getSides</a> (void)</td></tr>
<tr class="memdesc:a956ce069ca32ac15c53f9ca45f22ed13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the vector of Sides. <br /></td></tr>
<tr class="separator:a956ce069ca32ac15c53f9ca45f22ed13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cb02e3e71a61d80daed631401f5477"><td class="memItemLeft" align="right" valign="top"><a id="ab1cb02e3e71a61d80daed631401f5477"></a>
NexesById&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#ab1cb02e3e71a61d80daed631401f5477">getNexusLookup</a> (void)</td></tr>
<tr class="memdesc:ab1cb02e3e71a61d80daed631401f5477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the <a class="el" href="classdialect_1_1Nexus.html">Nexus</a> lookup. <br /></td></tr>
<tr class="separator:ab1cb02e3e71a61d80daed631401f5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a49e54941631230f86ea9e706880fbe"><td class="memItemLeft" align="right" valign="top"><a id="a2a49e54941631230f86ea9e706880fbe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a2a49e54941631230f86ea9e706880fbe">containsNodeIdSeq</a> (std::vector&lt; id_type &gt; idSeq) const</td></tr>
<tr class="memdesc:a2a49e54941631230f86ea9e706880fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method, to test whether the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> contains a given sequence of <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> IDs, in clockwise cyclic order. <br /></td></tr>
<tr class="separator:a2a49e54941631230f86ea9e706880fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5504ec8695d1deb441c8ff16901e2d"><td class="memItemLeft" align="right" valign="top"><a id="a6c5504ec8695d1deb441c8ff16901e2d"></a>
Graph_SP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a6c5504ec8695d1deb441c8ff16901e2d">getGraph</a> (void)</td></tr>
<tr class="memdesc:a6c5504ec8695d1deb441c8ff16901e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>. <br /></td></tr>
<tr class="separator:a6c5504ec8695d1deb441c8ff16901e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc5b920f53e94d37a6f0f363d17b29d"><td class="memItemLeft" align="right" valign="top">id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a5cc5b920f53e94d37a6f0f363d17b29d">id</a> (void) const</td></tr>
<tr class="memdesc:a5cc5b920f53e94d37a6f0f363d17b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the unique ID of a given instance.  <a href="#a5cc5b920f53e94d37a6f0f363d17b29d">More...</a><br /></td></tr>
<tr class="separator:a5cc5b920f53e94d37a6f0f363d17b29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac245bf52332658e65be156fdd23319ce"><td class="memItemLeft" align="right" valign="top"><a id="ac245bf52332658e65be156fdd23319ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#ac245bf52332658e65be156fdd23319ce">isExternal</a> (void) const</td></tr>
<tr class="memdesc:ac245bf52332658e65be156fdd23319ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this is the external face or not. <br /></td></tr>
<tr class="separator:ac245bf52332658e65be156fdd23319ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07b4bfd2018f9235d40e36b4e4ac572"><td class="memItemLeft" align="right" valign="top"><a id="ad07b4bfd2018f9235d40e36b4e4ac572"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#ad07b4bfd2018f9235d40e36b4e4ac572">toString</a> (void) const</td></tr>
<tr class="memdesc:ad07b4bfd2018f9235d40e36b4e4ac572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation. <br /></td></tr>
<tr class="separator:ad07b4bfd2018f9235d40e36b4e4ac572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf29bf1b757c72fdf2b12d9ddf15902e"><td class="memItemLeft" align="right" valign="top"><a id="adf29bf1b757c72fdf2b12d9ddf15902e"></a>
std::map&lt; id_type, std::vector&lt; std::pair&lt; Node_SP, Node_SP &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#adf29bf1b757c72fdf2b12d9ddf15902e">getNbrPairs</a> (void)</td></tr>
<tr class="memdesc:adf29bf1b757c72fdf2b12d9ddf15902e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the neighbour pairs. <br /></td></tr>
<tr class="separator:adf29bf1b757c72fdf2b12d9ddf15902e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e01f272e55794796d2797bc6507bbc7"><td class="memItemLeft" align="right" valign="top"><a id="a5e01f272e55794796d2797bc6507bbc7"></a>
Sides&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7">getRelevantSidesForPlacement</a> (TreePlacement_SP tp) const</td></tr>
<tr class="memdesc:a5e01f272e55794796d2797bc6507bbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of all Sides that are relevant to a given <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a>. <br /></td></tr>
<tr class="separator:a5e01f272e55794796d2797bc6507bbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38353723caf41d925accf6d7d4b9359d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a38353723caf41d925accf6d7d4b9359d">listAllPossibleTreePlacements</a> (TreePlacements &amp;tps, Tree_SP tree, Node_SP root, HolaOpts opts)</td></tr>
<tr class="memdesc:a38353723caf41d925accf6d7d4b9359d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all the possible ways of placing a given Tree into this Faces, at a given root <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> belonging to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>.  <a href="#a38353723caf41d925accf6d7d4b9359d">More...</a><br /></td></tr>
<tr class="separator:a38353723caf41d925accf6d7d4b9359d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e31abbad1d0880dba9a98875303856"><td class="memItemLeft" align="right" valign="top">CompassDirs&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#ae6e31abbad1d0880dba9a98875303856">inwardDirsAvailable</a> (Node_SP node)</td></tr>
<tr class="memdesc:ae6e31abbad1d0880dba9a98875303856"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the compass directions in which an edge could point if it were anchored at the given <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a>, and pointed inward, into the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>.  <a href="#ae6e31abbad1d0880dba9a98875303856">More...</a><br /></td></tr>
<tr class="separator:ae6e31abbad1d0880dba9a98875303856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a08a2145f25ec0ef4125c71f7654a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#aa4a08a2145f25ec0ef4125c71f7654a3">insertTreeNode</a> (TreePlacement_SP tp, double padding=0)</td></tr>
<tr class="memdesc:aa4a08a2145f25ec0ef4125c71f7654a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be used after the face has been expanded to make room for the tree. This method adds a large node to the graph, representing the bounding box of the tree, with padding. The treenode is constrained to lie beside its root node.  <a href="#aa4a08a2145f25ec0ef4125c71f7654a3">More...</a><br /></td></tr>
<tr class="separator:aa4a08a2145f25ec0ef4125c71f7654a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192f4c6b9354dbd34f08e21e4c00dffc"><td class="memItemLeft" align="right" valign="top">ProjSeq_SP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a192f4c6b9354dbd34f08e21e4c00dffc">computeCollateralProjSeq</a> (TreePlacement_SP tp, double padding=0)</td></tr>
<tr class="memdesc:a192f4c6b9354dbd34f08e21e4c00dffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a projection sequence to remove/prevent overlaps between the given <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a>'s tree box, and any existing tree boxes or ordinary perimeter Nodes on relevant Sides of this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>.  <a href="#a192f4c6b9354dbd34f08e21e4c00dffc">More...</a><br /></td></tr>
<tr class="separator:a192f4c6b9354dbd34f08e21e4c00dffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a3f0c7d561c065a5a46a12bedd2f7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a70a3f0c7d561c065a5a46a12bedd2f7b">applyProjSeq</a> (<a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> &amp;ps)</td></tr>
<tr class="memdesc:a70a3f0c7d561c065a5a46a12bedd2f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for applying a <a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> with all the appropriate options.  <a href="#a70a3f0c7d561c065a5a46a12bedd2f7b">More...</a><br /></td></tr>
<tr class="separator:a70a3f0c7d561c065a5a46a12bedd2f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ed0b74e2b4f2e01fcbe1834db59c6c"><td class="memItemLeft" align="right" valign="top">ProjSeq_SP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a95ed0b74e2b4f2e01fcbe1834db59c6c">doCollateralExpansion</a> (TreePlacement_SP tp, double padding=-1)</td></tr>
<tr class="memdesc:a95ed0b74e2b4f2e01fcbe1834db59c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform collateral expansion for a given <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a>. This means pushing Nodes and tree boxes on relevant Sides out of the way, to make room for the new tree box.  <a href="#a95ed0b74e2b4f2e01fcbe1834db59c6c">More...</a><br /></td></tr>
<tr class="separator:a95ed0b74e2b4f2e01fcbe1834db59c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9714b3cf5e237c994d5cb8147f0e848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#aa9714b3cf5e237c994d5cb8147f0e848">buildBdrySegsFacingOneDir</a> (CardinalDir facingDir, LineSegments &amp;closedSegs, LineSegments &amp;openSegs, TreePlacement_SP ignoreTP=nullptr)</td></tr>
<tr class="memdesc:aa9714b3cf5e237c994d5cb8147f0e848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build LineSegments to represent all those segments of the internal boundary of this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> that face in a given direction. These segments can represent aligned Edges, or parts of boundaries of Nodes or tree boxes.  <a href="#aa9714b3cf5e237c994d5cb8147f0e848">More...</a><br /></td></tr>
<tr class="separator:aa9714b3cf5e237c994d5cb8147f0e848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88688ef6a874ad55668db7e21b7763f"><td class="memItemLeft" align="right" valign="top">ProjSeq_SP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#ad88688ef6a874ad55668db7e21b7763f">buildBestProjSeq</a> (TreePlacement_SP tp, double padding=0, bool doCostlierDimensionFirst=false, <a class="el" href="namespacedialect.html#a49dec62af432fbe3cb3c6ff2209bf91a">ExpansionEstimateMethod</a> estimateMethod=ExpansionEstimateMethod::CONSTRAINTS)</td></tr>
<tr class="memdesc:ad88688ef6a874ad55668db7e21b7763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the best projection sequence for a given tree placement.  <a href="#ad88688ef6a874ad55668db7e21b7763f">More...</a><br /></td></tr>
<tr class="separator:ad88688ef6a874ad55668db7e21b7763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91d488b0941cf9d0f3992302798cd8a"><td class="memItemLeft" align="right" valign="top">Sides&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#ab91d488b0941cf9d0f3992302798cd8a">getAllSidesOppositeSegment</a> (LineSegment &amp;seg, bool openInterval=false) const</td></tr>
<tr class="memdesc:ab91d488b0941cf9d0f3992302798cd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the Sides of this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> that lie opposite a given LineSegment.  <a href="#ab91d488b0941cf9d0f3992302798cd8a">More...</a><br /></td></tr>
<tr class="separator:ab91d488b0941cf9d0f3992302798cd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e6f51f78e9495d1c40ff0538d0d62d"><td class="memItemLeft" align="right" valign="top">TreePlacements&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a29e6f51f78e9495d1c40ff0538d0d62d">getAllTreePlacements</a> (void) const</td></tr>
<tr class="memdesc:a29e6f51f78e9495d1c40ff0538d0d62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all TreePlacements that have been added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>.  <a href="#a29e6f51f78e9495d1c40ff0538d0d62d">More...</a><br /></td></tr>
<tr class="separator:a29e6f51f78e9495d1c40ff0538d0d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f64ab6fc109e92e90fc46411f47020"><td class="memItemLeft" align="right" valign="top">std::set&lt; TreePlacement_SP &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a22f64ab6fc109e92e90fc46411f47020">getSetOfAllTreePlacements</a> (void) const</td></tr>
<tr class="memdesc:a22f64ab6fc109e92e90fc46411f47020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of all TreePlacements that have been added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>.  <a href="#a22f64ab6fc109e92e90fc46411f47020">More...</a><br /></td></tr>
<tr class="separator:a22f64ab6fc109e92e90fc46411f47020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad04d9f70c4e6b713fbe194b607e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a4bad04d9f70c4e6b713fbe194b607e93">getAllTreePlacements</a> (TreePlacements &amp;tps) const</td></tr>
<tr class="memdesc:a4bad04d9f70c4e6b713fbe194b607e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all TreePlacements that have been added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>.  <a href="#a4bad04d9f70c4e6b713fbe194b607e93">More...</a><br /></td></tr>
<tr class="separator:a4bad04d9f70c4e6b713fbe194b607e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d36437540ca67ee767dc4eeb6248ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html#a22d36437540ca67ee767dc4eeb6248ab">getNumTreesByGrowthDir</a> (std::map&lt; CardinalDir, size_t &gt; &amp;counts, bool scaleBySize=false) const</td></tr>
<tr class="memdesc:a22d36437540ca67ee767dc4eeb6248ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">After tree placements have been chosen and performed, get a count of trees by growth direction.  <a href="#a22d36437540ca67ee767dc4eeb6248ab">More...</a><br /></td></tr>
<tr class="separator:a22d36437540ca67ee767dc4eeb6248ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a single face of a 4-planar, orthogonal layout. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa09b20192dffed6544a6f54c0940511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09b20192dffed6544a6f54c0940511f">&#9670;&nbsp;</a></span>Face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dialect::Face::Face </td>
          <td>(</td>
          <td class="paramtype">Graph_SP &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td>The <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> to which the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a70a3f0c7d561c065a5a46a12bedd2f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a3f0c7d561c065a5a46a12bedd2f7b">&#9670;&nbsp;</a></span>applyProjSeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Face::applyProjSeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for applying a <a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> with all the appropriate options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>The <a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, saying whether all the projections were successful. </dd></dl>

<p class="reference">References <a class="el" href="structdialect_1_1ColaOptions.html#a3d825401e1cdd3956e567403bdf7b6cf">dialect::ColaOptions::preventOverlaps</a>, and <a class="el" href="structdialect_1_1ColaOptions.html#a47dc9df69a42da1201685d870b153080">dialect::ColaOptions::solidifyAlignedEdges</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Face.html#a95ed0b74e2b4f2e01fcbe1834db59c6c">doCollateralExpansion()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a70a3f0c7d561c065a5a46a12bedd2f7b_icgraph.png" border="0" usemap="#classdialect_1_1Face_a70a3f0c7d561c065a5a46a12bedd2f7b_icgraph" alt=""/></div>
<map name="classdialect_1_1Face_a70a3f0c7d561c065a5a46a12bedd2f7b_icgraph" id="classdialect_1_1Face_a70a3f0c7d561c065a5a46a12bedd2f7b_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a95ed0b74e2b4f2e01fcbe1834db59c6c" title="Perform collateral expansion for a given TreePlacement. This means pushing Nodes and tree boxes on re..." alt="" coords="237,5,413,47"/>
<area shape="rect" id="node3" href="classdialect_1_1Face.html#ad88688ef6a874ad55668db7e21b7763f" title="Build the best projection sequence for a given tree placement. " alt="" coords="461,5,621,47"/>
</map>
</div>

</div>
</div>
<a id="aa9714b3cf5e237c994d5cb8147f0e848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9714b3cf5e237c994d5cb8147f0e848">&#9670;&nbsp;</a></span>buildBdrySegsFacingOneDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Face::buildBdrySegsFacingOneDir </td>
          <td>(</td>
          <td class="paramtype">CardinalDir&#160;</td>
          <td class="paramname"><em>facingDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LineSegments &amp;&#160;</td>
          <td class="paramname"><em>closedSegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LineSegments &amp;&#160;</td>
          <td class="paramname"><em>openSegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreePlacement_SP&#160;</td>
          <td class="paramname"><em>ignoreTP</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build LineSegments to represent all those segments of the internal boundary of this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> that face in a given direction. These segments can represent aligned Edges, or parts of boundaries of Nodes or tree boxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facingDir</td><td>CardinalDir telling which side the segments should face. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closedSegs</td><td>Vector in which to store all constructed closed segments. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">openSegs</td><td>Vector in which to store all constructed open segments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignoreTP</td><td>Optional <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> whose collateral tree boxes should be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Whether a boundary segment is closed or open means whether one crosses the interior boundary of the face at the endpoints (yes for closed, no for open).</dd></dl>
<p>For example, if facingDir is SOUTH, then closedSegs will get one LineSegment for every horizontal <a class="el" href="classdialect_1_1Edge.html" title="The Edge class represents edges in a graph. ">Edge</a> in the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>, while openSegs will get a LineSegment representing the southern boundary of (a) each <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> in the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>, and (b) each Tree box in the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </p>

<p class="reference">References <a class="el" href="structdialect_1_1BoundingBox.html#a46d3a32da6da210ee41a945fc10184f8">dialect::BoundingBox::buildSideSegment()</a>, <a class="el" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7">getRelevantSidesForPlacement()</a>, <a class="el" href="classAvoid_1_1Point.html#af52c4c52a1931bcce39ae57fa8062e87">Avoid::Point::id</a>, <a class="el" href="classAvoid_1_1Point.html#ae5f6929ae6c39393e4409485461c3fe3">Avoid::Point::x</a>, and <a class="el" href="classAvoid_1_1Point.html#a518b9e1306fb14416e457ed23b9b8cee">Avoid::Point::y</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_aa9714b3cf5e237c994d5cb8147f0e848_cgraph.png" border="0" usemap="#classdialect_1_1Face_aa9714b3cf5e237c994d5cb8147f0e848_cgraph" alt=""/></div>
<map name="classdialect_1_1Face_aa9714b3cf5e237c994d5cb8147f0e848_cgraph" id="classdialect_1_1Face_aa9714b3cf5e237c994d5cb8147f0e848_cgraph">
<area shape="rect" id="node2" href="structdialect_1_1BoundingBox.html#a46d3a32da6da210ee41a945fc10184f8" title="Build a LineSegment representing a side of the box. " alt="" coords="228,5,375,47"/>
<area shape="rect" id="node3" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7" title="Get a vector of all Sides that are relevant to a given TreePlacement. " alt="" coords="213,71,389,112"/>
</map>
</div>

</div>
</div>
<a id="ad88688ef6a874ad55668db7e21b7763f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88688ef6a874ad55668db7e21b7763f">&#9670;&nbsp;</a></span>buildBestProjSeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProjSeq_SP Face::buildBestProjSeq </td>
          <td>(</td>
          <td class="paramtype">TreePlacement_SP&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doCostlierDimensionFirst</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedialect.html#a49dec62af432fbe3cb3c6ff2209bf91a">ExpansionEstimateMethod</a>&#160;</td>
          <td class="paramname"><em>estimateMethod</em> = <code>ExpansionEstimateMethod::CONSTRAINTS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the best projection sequence for a given tree placement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tp</td><td>The <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> to be added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>Optional padding for the new tree box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doCostlierDimensionFirst</td><td>See <a class="el" href="classdialect_1_1TreePlacement.html#a559f9532293e745c8048d8e605195edc" title="Build the best projection sequence for this tree placement. ">TreePlacement::buildBestProjSeq</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">estimateMethod</td><td>See defn of ExpansionEstimateMethod enum class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> representing the computed projection sequence. </dd></dl>

<p class="reference">References <a class="el" href="classdialect_1_1Face.html#a95ed0b74e2b4f2e01fcbe1834db59c6c">doCollateralExpansion()</a>, and <a class="el" href="namespacevpsc.html#a498ea1e279ae35b8aa2edac29a3ebc17a229d6184c9e0791207bce362fa9e2d3b">vpsc::XDIM</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_ad88688ef6a874ad55668db7e21b7763f_cgraph.png" border="0" usemap="#classdialect_1_1Face_ad88688ef6a874ad55668db7e21b7763f_cgraph" alt=""/></div>
<map name="classdialect_1_1Face_ad88688ef6a874ad55668db7e21b7763f_cgraph" id="classdialect_1_1Face_ad88688ef6a874ad55668db7e21b7763f_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a95ed0b74e2b4f2e01fcbe1834db59c6c" title="Perform collateral expansion for a given TreePlacement. This means pushing Nodes and tree boxes on re..." alt="" coords="213,35,389,76"/>
<area shape="rect" id="node3" href="classdialect_1_1Face.html#a192f4c6b9354dbd34f08e21e4c00dffc" title="Compute a projection sequence to remove/prevent overlaps between the given TreePlacement&#39;s tree box..." alt="" coords="437,5,649,47"/>
<area shape="rect" id="node5" href="classdialect_1_1Face.html#a70a3f0c7d561c065a5a46a12bedd2f7b" title="Convenience function for applying a ProjSeq with all the appropriate options. " alt="" coords="451,71,635,98"/>
<area shape="rect" id="node4" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7" title="Get a vector of all Sides that are relevant to a given TreePlacement. " alt="" coords="697,5,873,47"/>
</map>
</div>

</div>
</div>
<a id="a192f4c6b9354dbd34f08e21e4c00dffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192f4c6b9354dbd34f08e21e4c00dffc">&#9670;&nbsp;</a></span>computeCollateralProjSeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProjSeq_SP Face::computeCollateralProjSeq </td>
          <td>(</td>
          <td class="paramtype">TreePlacement_SP&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a projection sequence to remove/prevent overlaps between the given <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a>'s tree box, and any existing tree boxes or ordinary perimeter Nodes on relevant Sides of this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tp</td><td>The <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> to be added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>Optional padding for the new tree box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> representing the computed projection sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the case where tp's root lies on two sides of the face, these two sides must be aligned in complementary dimensions (i.e. one in x, and one in y), so the sepcos generated here are always independent.</dd></dl>
<p>That is, if each side has an existing treenode that must be pushed away, the sepco for one tree will never achieve the push for the other, since these pushes /must/ be done in complementary dimensions.</p>
<p>Therefore there is no need to wait until after the first removal has been actually performed to compute the sepco for the second removal; it cannot be affected by the first one. This means we can safely compute them simultaneously. </p>

<p class="reference">References <a class="el" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7">getRelevantSidesForPlacement()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Face.html#a95ed0b74e2b4f2e01fcbe1834db59c6c">doCollateralExpansion()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_cgraph.png" border="0" usemap="#classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_cgraph" alt=""/></div>
<map name="classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_cgraph" id="classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7" title="Get a vector of all Sides that are relevant to a given TreePlacement. " alt="" coords="265,5,441,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_icgraph.png" border="0" usemap="#classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_icgraph" alt=""/></div>
<map name="classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_icgraph" id="classdialect_1_1Face_a192f4c6b9354dbd34f08e21e4c00dffc_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a95ed0b74e2b4f2e01fcbe1834db59c6c" title="Perform collateral expansion for a given TreePlacement. This means pushing Nodes and tree boxes on re..." alt="" coords="265,5,441,47"/>
<area shape="rect" id="node3" href="classdialect_1_1Face.html#ad88688ef6a874ad55668db7e21b7763f" title="Build the best projection sequence for a given tree placement. " alt="" coords="489,5,649,47"/>
</map>
</div>

</div>
</div>
<a id="a95ed0b74e2b4f2e01fcbe1834db59c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ed0b74e2b4f2e01fcbe1834db59c6c">&#9670;&nbsp;</a></span>doCollateralExpansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProjSeq_SP Face::doCollateralExpansion </td>
          <td>(</td>
          <td class="paramtype">TreePlacement_SP&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>padding</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform collateral expansion for a given <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a>. This means pushing Nodes and tree boxes on relevant Sides out of the way, to make room for the new tree box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tp</td><td>The <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> requiring space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>Optional padding to be added to the new tree box. Leave negative if you want padding equal to iel/4 to be automatically applied, where iel is the underlying graph's current ideal edge length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> that was used to achieve the required expansion. This <a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a> will have been already evaluated and applied when returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Runtime</td><td>exception if any of the collateral expansion projections are infeasible. In theory this should never happen. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classdialect_1_1Face.html#a70a3f0c7d561c065a5a46a12bedd2f7b">applyProjSeq()</a>, and <a class="el" href="classdialect_1_1Face.html#a192f4c6b9354dbd34f08e21e4c00dffc">computeCollateralProjSeq()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Face.html#ad88688ef6a874ad55668db7e21b7763f">buildBestProjSeq()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_cgraph.png" border="0" usemap="#classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_cgraph" alt=""/></div>
<map name="classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_cgraph" id="classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a70a3f0c7d561c065a5a46a12bedd2f7b" title="Convenience function for applying a ProjSeq with all the appropriate options. " alt="" coords="243,5,427,32"/>
<area shape="rect" id="node3" href="classdialect_1_1Face.html#a192f4c6b9354dbd34f08e21e4c00dffc" title="Compute a projection sequence to remove/prevent overlaps between the given TreePlacement&#39;s tree box..." alt="" coords="229,57,441,98"/>
<area shape="rect" id="node4" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7" title="Get a vector of all Sides that are relevant to a given TreePlacement. " alt="" coords="489,57,665,98"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_icgraph.png" border="0" usemap="#classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_icgraph" alt=""/></div>
<map name="classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_icgraph" id="classdialect_1_1Face_a95ed0b74e2b4f2e01fcbe1834db59c6c_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#ad88688ef6a874ad55668db7e21b7763f" title="Build the best projection sequence for a given tree placement. " alt="" coords="229,5,389,47"/>
</map>
</div>

</div>
</div>
<a id="ab91d488b0941cf9d0f3992302798cd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91d488b0941cf9d0f3992302798cd8a">&#9670;&nbsp;</a></span>getAllSidesOppositeSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sides Face::getAllSidesOppositeSegment </td>
          <td>(</td>
          <td class="paramtype">LineSegment &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>openInterval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the Sides of this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> that lie opposite a given LineSegment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seg</td><td>The LineSegment in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">openInterval</td><td>Set true if you want to consider the overlap with the LineSegment's open interval instead of closed (the default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of Sides. </dd></dl>

</div>
</div>
<a id="a29e6f51f78e9495d1c40ff0538d0d62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e6f51f78e9495d1c40ff0538d0d62d">&#9670;&nbsp;</a></span>getAllTreePlacements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreePlacements Face::getAllTreePlacements </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all TreePlacements that have been added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of TreePlacements. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Face.html#a22d36437540ca67ee767dc4eeb6248ab">getNumTreesByGrowthDir()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a29e6f51f78e9495d1c40ff0538d0d62d_icgraph.png" border="0" usemap="#classdialect_1_1Face_a29e6f51f78e9495d1c40ff0538d0d62d_icgraph" alt=""/></div>
<map name="classdialect_1_1Face_a29e6f51f78e9495d1c40ff0538d0d62d_icgraph" id="classdialect_1_1Face_a29e6f51f78e9495d1c40ff0538d0d62d_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a22d36437540ca67ee767dc4eeb6248ab" title="After tree placements have been chosen and performed, get a count of trees by growth direction..." alt="" coords="219,5,404,47"/>
</map>
</div>

</div>
</div>
<a id="a4bad04d9f70c4e6b713fbe194b607e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bad04d9f70c4e6b713fbe194b607e93">&#9670;&nbsp;</a></span>getAllTreePlacements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Face::getAllTreePlacements </td>
          <td>(</td>
          <td class="paramtype">TreePlacements &amp;&#160;</td>
          <td class="paramname"><em>tps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all TreePlacements that have been added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tps</td><td>Vector of TreePlacements to which those belonging to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d36437540ca67ee767dc4eeb6248ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d36437540ca67ee767dc4eeb6248ab">&#9670;&nbsp;</a></span>getNumTreesByGrowthDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Face::getNumTreesByGrowthDir </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; CardinalDir, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaleBySize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After tree placements have been chosen and performed, get a count of trees by growth direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>Map into which the counts should be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaleBySize</td><td>Set true if for each tree you actually want to count its number of nodes. In other words, the final counts you get actually indicate the number of nodes in trees that grow in the given directions. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classdialect_1_1Face.html#a29e6f51f78e9495d1c40ff0538d0d62d">getAllTreePlacements()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a22d36437540ca67ee767dc4eeb6248ab_cgraph.png" border="0" usemap="#classdialect_1_1Face_a22d36437540ca67ee767dc4eeb6248ab_cgraph" alt=""/></div>
<map name="classdialect_1_1Face_a22d36437540ca67ee767dc4eeb6248ab_cgraph" id="classdialect_1_1Face_a22d36437540ca67ee767dc4eeb6248ab_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a29e6f51f78e9495d1c40ff0538d0d62d" title="Get all TreePlacements that have been added to this Face. " alt="" coords="239,5,404,47"/>
</map>
</div>

</div>
</div>
<a id="a22f64ab6fc109e92e90fc46411f47020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f64ab6fc109e92e90fc46411f47020">&#9670;&nbsp;</a></span>getSetOfAllTreePlacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; TreePlacement_SP &gt; Face::getSetOfAllTreePlacements </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the set of all TreePlacements that have been added to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Set of TreePlacements. </dd></dl>

</div>
</div>
<a id="a5cc5b920f53e94d37a6f0f363d17b29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc5b920f53e94d37a6f0f363d17b29d">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">id_type dialect::Face::id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the unique ID of a given instance. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID. </dd></dl>

</div>
</div>
<a id="aa4a08a2145f25ec0ef4125c71f7654a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a08a2145f25ec0ef4125c71f7654a3">&#9670;&nbsp;</a></span>insertTreeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Face::insertTreeNode </td>
          <td>(</td>
          <td class="paramtype">TreePlacement_SP&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be used after the face has been expanded to make room for the tree. This method adds a large node to the graph, representing the bounding box of the tree, with padding. The treenode is constrained to lie beside its root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tp</td><td>A <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> representing the Tree to be placed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>Optional padding to be added to the tree box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>TreePlacement::getTreeBox for interpretation of the padding. </dd></dl>

<p class="reference">References <a class="el" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7">getRelevantSidesForPlacement()</a>, <a class="el" href="classAvoid_1_1Point.html#ae5f6929ae6c39393e4409485461c3fe3">Avoid::Point::x</a>, and <a class="el" href="classAvoid_1_1Point.html#a518b9e1306fb14416e457ed23b9b8cee">Avoid::Point::y</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1TreePlacement.html#a74081ff9faadcd88a03dce278d9c7be9">dialect::TreePlacement::insertTreeNode()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_cgraph.png" border="0" usemap="#classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_cgraph" alt=""/></div>
<map name="classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_cgraph" id="classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a5e01f272e55794796d2797bc6507bbc7" title="Get a vector of all Sides that are relevant to a given TreePlacement. " alt="" coords="251,5,427,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_icgraph.png" border="0" usemap="#classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_icgraph" alt=""/></div>
<map name="classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_icgraph" id="classdialect_1_1Face_aa4a08a2145f25ec0ef4125c71f7654a3_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1TreePlacement.html#a74081ff9faadcd88a03dce278d9c7be9" title="Insert a node representing the Tree into the Face to which this placement belongs. " alt="" coords="251,5,409,47"/>
</map>
</div>

</div>
</div>
<a id="ae6e31abbad1d0880dba9a98875303856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e31abbad1d0880dba9a98875303856">&#9670;&nbsp;</a></span>inwardDirsAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CompassDirs Face::inwardDirsAvailable </td>
          <td>(</td>
          <td class="paramtype">Node_SP&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the compass directions in which an edge could point if it were anchored at the given <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a>, and pointed inward, into the <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </p>
<p>Because of the way the faces are traced out, swinging from the previous node to the next one sweeps out an area of the /inside/ of this face when you go /anticlockwise/.</p>
<p>Therefore if d0 is the compass direction from node to prev, and if d1 is that from node to next, then the available directions are all those strictly between d0 and d1 /in the anticlockwise direction/.</p>
<p>For example, if node &ndash;&gt; prev points South while node &ndash;&gt; next points West, then both East and North are available. But if node &ndash;&gt; prev points East while node &ndash;&gt; next points North, then only NE is available.</p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Face.html#a38353723caf41d925accf6d7d4b9359d">listAllPossibleTreePlacements()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_ae6e31abbad1d0880dba9a98875303856_icgraph.png" border="0" usemap="#classdialect_1_1Face_ae6e31abbad1d0880dba9a98875303856_icgraph" alt=""/></div>
<map name="classdialect_1_1Face_ae6e31abbad1d0880dba9a98875303856_icgraph" id="classdialect_1_1Face_ae6e31abbad1d0880dba9a98875303856_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#a38353723caf41d925accf6d7d4b9359d" title="Compute all the possible ways of placing a given Tree into this Faces, at a given root Node belonging..." alt="" coords="221,5,408,47"/>
</map>
</div>

</div>
</div>
<a id="a38353723caf41d925accf6d7d4b9359d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38353723caf41d925accf6d7d4b9359d">&#9670;&nbsp;</a></span>listAllPossibleTreePlacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Face::listAllPossibleTreePlacements </td>
          <td>(</td>
          <td class="paramtype">TreePlacements &amp;&#160;</td>
          <td class="paramname"><em>tps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tree_SP&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node_SP&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HolaOpts&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all the possible ways of placing a given Tree into this Faces, at a given root <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> belonging to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tps</td><td>A vector of TreePlacements to which all those allocated by this method are to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>The Tree to be placed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a>, belonging to this <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>, where the Tree is to attach. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Options to control which kinds of placements are defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If opts.treePlacement_favourCardinal == true, then we will report ordinal placement options if and only if there are no possible cardinal placement options. For example, if {NE, E, SE} were available, we would construct a <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> only on the E placement direction; however if only {NE, SE} were available, we would construct a <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> for each of these ordinal directions. </dd></dl>

<p class="reference">References <a class="el" href="classdialect_1_1Face.html#ae6e31abbad1d0880dba9a98875303856">inwardDirsAvailable()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1Face_a38353723caf41d925accf6d7d4b9359d_cgraph.png" border="0" usemap="#classdialect_1_1Face_a38353723caf41d925accf6d7d4b9359d_cgraph" alt=""/></div>
<map name="classdialect_1_1Face_a38353723caf41d925accf6d7d4b9359d_cgraph" id="classdialect_1_1Face_a38353723caf41d925accf6d7d4b9359d_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Face.html#ae6e31abbad1d0880dba9a98875303856" title="List the compass directions in which an edge could point if it were anchored at the given Node..." alt="" coords="240,5,408,47"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libdialect/<a class="el" href="faces_8h_source.html">faces.h</a></li>
<li>libdialect/faces.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 17 2019 14:55:41 for Adaptagrams by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
