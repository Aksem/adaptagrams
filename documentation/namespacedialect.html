<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptagrams: dialect Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptagrams
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dialect Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>libdialect: A library for computing human-like orthogonal network (DiAlEcT) layouts.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html">ACALayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Adaptive Constrained Alignment (ACA) algorithm.  <a href="classdialect_1_1ACALayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1AestheticBend.html">AestheticBend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bend point deliberately added to a connector route, for aesthetic reasons.  <a href="structdialect_1_1AestheticBend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1Arrangement.html">Arrangement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the arrangement of all Nbrs around a centre node.  <a href="structdialect_1_1Arrangement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1Assignment.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an assignment of nbrs to semiaxes, and records the cost of this assignment.  <a href="structdialect_1_1Assignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1BendSequence.html">BendSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure for managing sequences of bend types, points at which these bends should occur (in a given <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a>), cost of such a sequence of bends (for a given <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a>), and incoming and outgoing Compass directions, for non-cycles.  <a href="structdialect_1_1BendSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1BoundingBox.html">BoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bounding box, given by the extreme coordinates.  <a href="structdialect_1_1BoundingBox.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Chain.html">Chain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a> is a sequence of degree-2 Nodes, possibly forming a cycle.  <a href="classdialect_1_1Chain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1ColaGraphRep.html">ColaGraphRep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles those data structures required in order to represent a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> in libcola, and to map infomration between the libcola and libdialect representations.  <a href="structdialect_1_1ColaGraphRep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1ColaOptions.html">ColaOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a simple way to set any or all of the various optional arguments to libcola layout methods.  <a href="structdialect_1_1ColaOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classdialect_1_1Edge.html" title="The Edge class represents edges in a graph. ">Edge</a> class represents edges in a graph.  <a href="classdialect_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1EdgeSegment.html">EdgeSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an axis-aligned segment of an orthogonal connector route.  <a href="structdialect_1_1EdgeSegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ExpansionGoal.html">ExpansionGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classdialect_1_1ExpansionGoal.html" title="The ExpansionGoal class. ">ExpansionGoal</a> class.  <a href="classdialect_1_1ExpansionGoal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ExpansionManager.html">ExpansionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classdialect_1_1ExpansionManager.html" title="The ExpansionManager class. ">ExpansionManager</a> class.  <a href="classdialect_1_1ExpansionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single face of a 4-planar, orthogonal layout.  <a href="classdialect_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1FaceSet.html">FaceSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1GhostNode.html">GhostNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdialect_1_1GhostNode.html" title="A GhostNode represents another Node. ">GhostNode</a> represents another <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a>.  <a href="classdialect_1_1GhostNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> class represents graphs consisting of nodes and edges.  <a href="classdialect_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1LeaflessOrthoRouter.html">LeaflessOrthoRouter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a special orthogonal routing in a graph having no leaves, ensuring that at least two distinct sides of every node are used as connection points. This is useful if we later wish to planarise the layout, since it ensures that no node will become a leaf in that process.  <a href="classdialect_1_1LeaflessOrthoRouter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1Matrix2d.html">Matrix2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense 2d array, with integer indices.  <a href="structdialect_1_1Matrix2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1Nbr.html">Nbr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a neighbouring node to a central node.  <a href="structdialect_1_1Nbr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1NearbyObjectFinder.html">NearbyObjectFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Nexus.html">Nexus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> class represents nodes in a graph.  <a href="classdialect_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1NodeBuckets.html">NodeBuckets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1NodeIdCmp.html">NodeIdCmp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for set operations on <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> lookups.  <a href="structdialect_1_1NodeIdCmp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1OrthoHubLayout.html">OrthoHubLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A layout object that tries to orthogonalise hubs. This means it visits nodes of degrees 3 or higher, and tries to set their neighbours in cardinal compass directions from it.  <a href="classdialect_1_1OrthoHubLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1OrthoHubLayoutOptions.html">OrthoHubLayoutOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control <a class="el" href="classdialect_1_1OrthoHubLayout.html" title="A layout object that tries to orthogonalise hubs. This means it visits nodes of degrees 3 or higher...">OrthoHubLayout</a>.  <a href="structdialect_1_1OrthoHubLayoutOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1OrthoPlanariser.html">OrthoPlanariser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1PeeledNode.html">PeeledNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdialect_1_1PeeledNode.html" title="A PeeledNode is a type of GhostNode, used in the peeling process. ">PeeledNode</a> is a type of <a class="el" href="classdialect_1_1GhostNode.html" title="A GhostNode represents another Node. ">GhostNode</a>, used in the peeling process.  <a href="classdialect_1_1PeeledNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1Projection.html">Projection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ProjSeq.html">ProjSeq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1Quad.html">Quad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a quadrant, relative to a central node.  <a href="structdialect_1_1Quad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1RoutingAdapter.html">RoutingAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to easily apply libavoid::Routers to libdialect::Graphs.  <a href="structdialect_1_1RoutingAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1SepCo.html">SepCo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1SepPairSubConstraintInfo.html">SepPairSubConstraintInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1Side.html">Side</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A side of a <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a>. E.g. a rectangular <a class="el" href="classdialect_1_1Face.html" title="Represents a single face of a 4-planar, orthogonal layout. ">Face</a> has four Sides: north, south, east, and west.  <a href="classdialect_1_1Side.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdialect_1_1Stem.html">Stem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a leaf node, along with its one edge and neighbour.  <a href="structdialect_1_1Stem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aeffe119eae768555a5403af3e03efd44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a> </td></tr>
<tr class="separator:aeffe119eae768555a5403af3e03efd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a18a3008fef6ccbd5e00bbe782ebf6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#ac6a18a3008fef6ccbd5e00bbe782ebf6">GapType</a> { <a class="el" href="namespacedialect.html#ac6a18a3008fef6ccbd5e00bbe782ebf6a861d9b366d4c6f701fbc59ba9ab7bdda">GapType::CENTRE</a>, 
<a class="el" href="namespacedialect.html#ac6a18a3008fef6ccbd5e00bbe782ebf6af8ea4697a0ba147f58031c8f1fcc093a">GapType::BDRY</a>
 }</td></tr>
<tr class="separator:ac6a18a3008fef6ccbd5e00bbe782ebf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c3a074f26cf4a8ff4a209d7d61e4f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a074c3a074f26cf4a8ff4a209d7d61e4f">SepDir</a> { <a class="el" href="namespacedialect.html#a074c3a074f26cf4a8ff4a209d7d61e4fa45ac78bf3d4882ac520f4e7fb08d55c5">SepDir::EAST</a>
, <a class="el" href="namespacedialect.html#a074c3a074f26cf4a8ff4a209d7d61e4fa21507b40c80068eda19865706fdc2403">SepDir::RIGHT</a>
 }</td></tr>
<tr class="separator:a074c3a074f26cf4a8ff4a209d7d61e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167b9db8fcec7c8227b02856352cb2c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a167b9db8fcec7c8227b02856352cb2c1">SepType</a> { <a class="el" href="namespacedialect.html#a167b9db8fcec7c8227b02856352cb2c1ab50339a10e1de285ac99d4c3990b8693">SepType::NONE</a>, 
<a class="el" href="namespacedialect.html#a167b9db8fcec7c8227b02856352cb2c1a2dcbad7477fd40561e8b8198f173bd47">SepType::EQ</a>, 
<a class="el" href="namespacedialect.html#a167b9db8fcec7c8227b02856352cb2c1a1add9747ea47fe8dddeba609292fd3a9">SepType::INEQ</a>
 }</td></tr>
<tr class="separator:a167b9db8fcec7c8227b02856352cb2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cd2ccfb3d0994fd390d07820510ff6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6">SepTransform</a> { <br />
&#160;&#160;<a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6a86457d7a57e5f9180ace3c1fbbb40be9">SepTransform::ROTATE90CW</a>, 
<a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6ab45cdb7fc42321bde747029cbb1e5981">SepTransform::ROTATE90ACW</a>, 
<a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6a5788ed8b8d0ffb5e041f0404118950be">SepTransform::ROTATE180</a>, 
<a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6a069749d9f7b6c5bbf05dee2b6c288880">SepTransform::FLIPV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6a61027bc7cccbadf48390cac3b40fe673">SepTransform::FLIPH</a>, 
<a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6a88e29cb8be7080673157702982d19fe5">SepTransform::FLIPMD</a>, 
<a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6a4706bba6c8743f626350f74367c3f5d0">SepTransform::FLIPOD</a>
<br />
 }</td></tr>
<tr class="separator:ac3cd2ccfb3d0994fd390d07820510ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f240def052ed09e26b2b96feb871cf9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a5f240def052ed09e26b2b96feb871cf9">TreeRoutingType</a> </td></tr>
<tr class="separator:a5f240def052ed09e26b2b96feb871cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dec62af432fbe3cb3c6ff2209bf91a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a49dec62af432fbe3cb3c6ff2209bf91a">ExpansionEstimateMethod</a> </td></tr>
<tr class="separator:a49dec62af432fbe3cb3c6ff2209bf91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2833edc2f859f4d3f596558522748edd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a2833edc2f859f4d3f596558522748edd">RouteProcessing</a> { <a class="el" href="namespacedialect.html#a2833edc2f859f4d3f596558522748eddab50339a10e1de285ac99d4c3990b8693">RouteProcessing::NONE</a>, 
<a class="el" href="namespacedialect.html#a2833edc2f859f4d3f596558522748edda921df56002ee5dc960debedc8ae06072">RouteProcessing::RECORD</a>, 
<a class="el" href="namespacedialect.html#a2833edc2f859f4d3f596558522748edda345ddc1a5034d474b5f722a4fad57bcc">RouteProcessing::REFINE_AND_RECORD</a>
 }</td></tr>
<tr class="memdesc:a2833edc2f859f4d3f596558522748edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control how much processing should be done on connector routes by the RoutingAdapter.  <a href="namespacedialect.html#a2833edc2f859f4d3f596558522748edd">More...</a><br /></td></tr>
<tr class="separator:a2833edc2f859f4d3f596558522748edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aac506665928f0e3b882eb82274f951b2"><td class="memItemLeft" align="right" valign="top"><a id="aac506665928f0e3b882eb82274f951b2"></a>
LinkShapes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#aac506665928f0e3b882eb82274f951b2">bentLinkShapeCwFromStartingPt</a> (<a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a> start)</td></tr>
<tr class="memdesc:aac506665928f0e3b882eb82274f951b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bent LinkShapes, in clockwise order, starting from a given one. <br /></td></tr>
<tr class="separator:aac506665928f0e3b882eb82274f951b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13e7be712ac2f35c54fcc9e338d7902"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#ab13e7be712ac2f35c54fcc9e338d7902">lookupMinimalBendSeqs</a> (Node_SP A, CardinalDir d0, Node_SP Z, CardinalDir d1)</td></tr>
<tr class="memdesc:ab13e7be712ac2f35c54fcc9e338d7902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the minimal bend sequences for a <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a>.  <a href="#ab13e7be712ac2f35c54fcc9e338d7902">More...</a><br /></td></tr>
<tr class="separator:ab13e7be712ac2f35c54fcc9e338d7902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e392f82ee2647c96c18ebe2f499246f"><td class="memItemLeft" align="right" valign="top"><a id="a1e392f82ee2647c96c18ebe2f499246f"></a>
CardinalDirs&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a1e392f82ee2647c96c18ebe2f499246f">possibleCardinalDirections</a> (Node_SP node1, Node_SP node2)</td></tr>
<tr class="memdesc:a1e392f82ee2647c96c18ebe2f499246f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the possible cardinal directions from node1 to node2, if they were to be aligned non-aggressively. <br /></td></tr>
<tr class="separator:a1e392f82ee2647c96c18ebe2f499246f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed146a04dc4b872386c2c407e05c3ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#aaed146a04dc4b872386c2c407e05c3ce">shapeOfLink</a> (Node_SP link)</td></tr>
<tr class="memdesc:aaed146a04dc4b872386c2c407e05c3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the LinkShape for a given <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> of degree 2.  <a href="#aaed146a04dc4b872386c2c407e05c3ce">More...</a><br /></td></tr>
<tr class="separator:aaed146a04dc4b872386c2c407e05c3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c126f4a90d9e38c4b00e85db20f8c7"><td class="memItemLeft" align="right" valign="top"><a id="a78c126f4a90d9e38c4b00e85db20f8c7"></a>
Chains&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a78c126f4a90d9e38c4b00e85db20f8c7">buildAllChainsInGraph</a> (std::shared_ptr&lt; <a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &gt; graph)</td></tr>
<tr class="memdesc:a78c126f4a90d9e38c4b00e85db20f8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to build all the chains and cycles in a graph. <br /></td></tr>
<tr class="separator:a78c126f4a90d9e38c4b00e85db20f8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ccc4c149e1b5902ec827bfabd3cf76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76">doHOLA</a> (<a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &amp;G, const dialect::HolaOpts &amp;holaOpts, dialect::Logger *logger=nullptr)</td></tr>
<tr class="memdesc:a05ccc4c149e1b5902ec827bfabd3cf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the HOLA layout algorithm to the given <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>. See Steve Kieffer, Tim Dwyer, Kim Marriott, and Michael Wybrow. HOLA: Human-like Orthogonal Network Layout. IEEE Transactions on Visualization and Computer Graphics 22, no. 1 (2016): 349-358.  <a href="#a05ccc4c149e1b5902ec827bfabd3cf76">More...</a><br /></td></tr>
<tr class="separator:a05ccc4c149e1b5902ec827bfabd3cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24766038e1a9ccd99997ea31c42b432a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a">doHOLA</a> (<a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &amp;G)</td></tr>
<tr class="memdesc:a24766038e1a9ccd99997ea31c42b432a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to do HOLA layout with default options.  <a href="#a24766038e1a9ccd99997ea31c42b432a">More...</a><br /></td></tr>
<tr class="separator:a24766038e1a9ccd99997ea31c42b432a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03b2fb8b5aa1df28e32ed5f9f8cf98a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdialect_1_1Graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#ad03b2fb8b5aa1df28e32ed5f9f8cf98a">buildGraphFromTglf</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:ad03b2fb8b5aa1df28e32ed5f9f8cf98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> object from TGLF.  <a href="#ad03b2fb8b5aa1df28e32ed5f9f8cf98a">More...</a><br /></td></tr>
<tr class="separator:ad03b2fb8b5aa1df28e32ed5f9f8cf98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c94d23c1beda10e9881a8cca789aea2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdialect_1_1Graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a6c94d23c1beda10e9881a8cca789aea2">buildGraphFromTglf</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:a6c94d23c1beda10e9881a8cca789aea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> object from TGLF.  <a href="#a6c94d23c1beda10e9881a8cca789aea2">More...</a><br /></td></tr>
<tr class="separator:a6c94d23c1beda10e9881a8cca789aea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda74a96be09f93951039d7d5728877"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdialect_1_1Graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a6bda74a96be09f93951039d7d5728877">buildGraphFromTglfFile</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a6bda74a96be09f93951039d7d5728877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> object from a file containing TGLF.  <a href="#a6bda74a96be09f93951039d7d5728877">More...</a><br /></td></tr>
<tr class="separator:a6bda74a96be09f93951039d7d5728877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283777bcbb68f6dbdeb06222a9ad2fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a283777bcbb68f6dbdeb06222a9ad2fa3">writeStringToFile</a> (const std::string &amp;s, const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a283777bcbb68f6dbdeb06222a9ad2fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a string to a file.  <a href="#a283777bcbb68f6dbdeb06222a9ad2fa3">More...</a><br /></td></tr>
<tr class="separator:a283777bcbb68f6dbdeb06222a9ad2fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b55cb6356a52c3a520f0f2fd7ed060"><td class="memItemLeft" align="right" valign="top"><a id="a64b55cb6356a52c3a520f0f2fd7ed060"></a>
AlignmentFlag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a64b55cb6356a52c3a520f0f2fd7ed060">operator &amp;</a> (AlignmentFlag a, AlignmentFlag b)</td></tr>
<tr class="memdesc:a64b55cb6356a52c3a520f0f2fd7ed060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thanks to <a href="https://stackoverflow.com/a/1448478">https://stackoverflow.com/a/1448478</a>. <br /></td></tr>
<tr class="separator:a64b55cb6356a52c3a520f0f2fd7ed060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f273d273f8d0479f58ddec110e5ad2"><td class="memItemLeft" align="right" valign="top"><a id="ae1f273d273f8d0479f58ddec110e5ad2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#ae1f273d273f8d0479f58ddec110e5ad2">manhattan</a> (Node_SP u, Node_SP v)</td></tr>
<tr class="memdesc:ae1f273d273f8d0479f58ddec110e5ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the "Manhattan distance" between two nodes. <br /></td></tr>
<tr class="separator:ae1f273d273f8d0479f58ddec110e5ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e008284e07fda0a6c7e60e1d501dfa9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a0e008284e07fda0a6c7e60e1d501dfa9">doNearAlignments</a> (<a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &amp;graph, dialect::AlignmentTable &amp;atab, dialect::NodesById &amp;ignore, const dialect::HolaOpts &amp;opts, bool reattempt=false)</td></tr>
<tr class="memdesc:a0e008284e07fda0a6c7e60e1d501dfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for nodes that are nearly aligned, and try to align them.  <a href="#a0e008284e07fda0a6c7e60e1d501dfa9">More...</a><br /></td></tr>
<tr class="separator:a0e008284e07fda0a6c7e60e1d501dfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348cb1a0dfe6202d4ff711029a4ccf8e"><td class="memItemLeft" align="right" valign="top">PeeledNode_SP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a348cb1a0dfe6202d4ff711029a4ccf8e">identifyRootNode</a> (const <a class="el" href="classdialect_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a348cb1a0dfe6202d4ff711029a4ccf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as "root" the <a class="el" href="classdialect_1_1PeeledNode.html" title="A PeeledNode is a type of GhostNode, used in the peeling process. ">PeeledNode</a> having largest serial number.  <a href="#a348cb1a0dfe6202d4ff711029a4ccf8e">More...</a><br /></td></tr>
<tr class="separator:a348cb1a0dfe6202d4ff711029a4ccf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4dc6aea10cd3c086f57c1be3960aeb"><td class="memItemLeft" align="right" valign="top"><a id="a7e4dc6aea10cd3c086f57c1be3960aeb"></a>
std::vector&lt; Stem_SP &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a7e4dc6aea10cd3c086f57c1be3960aeb">makeStemsFromLeaves</a> (const NodesById &amp;leaves)</td></tr>
<tr class="memdesc:a7e4dc6aea10cd3c086f57c1be3960aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structdialect_1_1Stem.html" title="Represents a leaf node, along with its one edge and neighbour. ">Stem</a> object to represent each leaf. <br /></td></tr>
<tr class="separator:a7e4dc6aea10cd3c086f57c1be3960aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b1d1583bf8668dde5e0252a2205eb1"><td class="memItemLeft" align="right" valign="top">Trees&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a29b1d1583bf8668dde5e0252a2205eb1">peel</a> (<a class="el" href="classdialect_1_1Graph.html">Graph</a> &amp;G)</td></tr>
<tr class="memdesc:a29b1d1583bf8668dde5e0252a2205eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the "peeling" process, in which the exterior trees are removed from the given <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>.  <a href="#a29b1d1583bf8668dde5e0252a2205eb1">More...</a><br /></td></tr>
<tr class="separator:a29b1d1583bf8668dde5e0252a2205eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f57d3ab3a9d4b5e7fc82d40e97385b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a96f57d3ab3a9d4b5e7fc82d40e97385b">CompareActiveEvents</a> (Event *a, Event *b)</td></tr>
<tr class="separator:a96f57d3ab3a9d4b5e7fc82d40e97385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe70f9004b1b9e78730273e67aa1d76"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#afbe70f9004b1b9e78730273e67aa1d76">lookupQuadActions</a> (size_t p, size_t q, size_t r, size_t s, size_t c)</td></tr>
<tr class="memdesc:afbe70f9004b1b9e78730273e67aa1d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up legal quad actions.  <a href="#afbe70f9004b1b9e78730273e67aa1d76">More...</a><br /></td></tr>
<tr class="separator:afbe70f9004b1b9e78730273e67aa1d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d325ef46ea3385428712f16fedf71ef"><td class="memItemLeft" align="right" valign="top"><a id="a9d325ef46ea3385428712f16fedf71ef"></a>
FaceSet_SP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a9d325ef46ea3385428712f16fedf71ef">reattachTrees</a> (Graph_SP core, Trees trees, HolaOpts opts, Logger *logger=nullptr)</td></tr>
<tr class="memdesc:a9d325ef46ea3385428712f16fedf71ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a planar orthogonal core, and the corresponding Trees (as resulting from the peeling process), choose Faces of the core in which to place the Trees, generate constraints to expand those Faces, and insert large Nodes to represent the bounding boxes of the Trees. <br /></td></tr>
<tr class="separator:a9d325ef46ea3385428712f16fedf71ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c07364fd697fc53a40c3dd7099ed95"><td class="memItemLeft" align="right" valign="top"><a id="a74c07364fd697fc53a40c3dd7099ed95"></a>
TreePlacement_SP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a74c07364fd697fc53a40c3dd7099ed95">chooseBestPlacement</a> (TreePlacements tps, HolaOpts opts)</td></tr>
<tr class="memdesc:a74c07364fd697fc53a40c3dd7099ed95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the best <a class="el" href="classdialect_1_1TreePlacement.html">TreePlacement</a> from among a list of alternatives. <br /></td></tr>
<tr class="separator:a74c07364fd697fc53a40c3dd7099ed95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f558d7aec6b04a1f52fde6c4796b77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a67f558d7aec6b04a1f52fde6c4796b77">logically_equal</a> (double a, double b, double error_factor=1.0)</td></tr>
<tr class="memdesc:a67f558d7aec6b04a1f52fde6c4796b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerant equality test for doubles. Generates principled value for tolerance.  <a href="#a67f558d7aec6b04a1f52fde6c4796b77">More...</a><br /></td></tr>
<tr class="separator:a67f558d7aec6b04a1f52fde6c4796b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ae5917d7b3766917afc693c9343245"><td class="memItemLeft" align="right" valign="top"><a id="a24ae5917d7b3766917afc693c9343245"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a24ae5917d7b3766917afc693c9343245">approx_equal</a> (double a, double b, double tol=0.000001)</td></tr>
<tr class="memdesc:a24ae5917d7b3766917afc693c9343245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerant equality test for doubles. Uses arbitrary tolerance. <br /></td></tr>
<tr class="separator:a24ae5917d7b3766917afc693c9343245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdbc3f53251706e91936da1109bb644"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a7fdbc3f53251706e91936da1109bb644"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a7fdbc3f53251706e91936da1109bb644">string_format</a> (const std::string &amp;format, Args ... args)</td></tr>
<tr class="memdesc:a7fdbc3f53251706e91936da1109bb644"><td class="mdescLeft">&#160;</td><td class="mdescRight">String formatting.  <a href="#a7fdbc3f53251706e91936da1109bb644">More...</a><br /></td></tr>
<tr class="separator:a7fdbc3f53251706e91936da1109bb644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ef85dafcc63a44823c914a5d54a425"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ef85dafcc63a44823c914a5d54a425"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedialect.html#ad2ef85dafcc63a44823c914a5d54a425">partition</a> (std::vector&lt; T &gt; items, std::function&lt; double(T)&gt; key, double tolerance=0)</td></tr>
<tr class="memdesc:ad2ef85dafcc63a44823c914a5d54a425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a vector of items according to a key value.  <a href="#ad2ef85dafcc63a44823c914a5d54a425">More...</a><br /></td></tr>
<tr class="separator:ad2ef85dafcc63a44823c914a5d54a425"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a93fdcce99f7e6240de3e059bc7888591"><td class="memItemLeft" align="right" valign="top"><a id="a93fdcce99f7e6240de3e059bc7888591"></a>
const LinkShapes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a93fdcce99f7e6240de3e059bc7888591">bentLinkShapeCw</a></td></tr>
<tr class="memdesc:a93fdcce99f7e6240de3e059bc7888591"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bent LinkShapes, in clockwise order: <br /></td></tr>
<tr class="separator:a93fdcce99f7e6240de3e059bc7888591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a3a7bf46544f6dd744c452a4bca7c5"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a>, std::map&lt; CardinalDir, CardinalDir &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#aa2a3a7bf46544f6dd744c452a4bca7c5">applyBendToDir</a></td></tr>
<tr class="separator:aa2a3a7bf46544f6dd744c452a4bca7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9609206857646fa04632aef75676b1ea"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a>, CardinalDir &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a9609206857646fa04632aef75676b1ea">cwIncomingDirForBend</a></td></tr>
<tr class="separator:a9609206857646fa04632aef75676b1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3a4f45528895913df2c82515700332"><td class="memItemLeft" align="right" valign="top">const std::map&lt; CompassDir, std::map&lt; CardinalDir, std::map&lt; CardinalDir, std::vector&lt; std::vector&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a> &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#aee3a4f45528895913df2c82515700332">minimalBendSeqs</a></td></tr>
<tr class="separator:aee3a4f45528895913df2c82515700332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429978c394e78f7e95f6ab9a3bc1e1fe"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedialect.html#a429978c394e78f7e95f6ab9a3bc1e1fe">SEMIAXIS_SETS_BY_CARDINALITY</a> [5]</td></tr>
<tr class="separator:a429978c394e78f7e95f6ab9a3bc1e1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>libdialect: A library for computing human-like orthogonal network (DiAlEcT) layouts. </p>
<p>This header defines tools for working with the "chains", i.e. maximal subgraphs composed entirely of "links" (nodes of degree 2), in 4-planar orthogonal layouts. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a49dec62af432fbe3cb3c6ff2209bf91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dec62af432fbe3cb3c6ff2209bf91a">&#9670;&nbsp;</a></span>ExpansionEstimateMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#a49dec62af432fbe3cb3c6ff2209bf91a">dialect::ExpansionEstimateMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When expanding faces in order to make room to place the trees, there are different ways to estimate which is the best dimension in which to operate first.</p>
<p>SPACE: Look at the available space in each dimension. CONSTRAINTS: Compute the separation constraints you would use in each dimension, and sum their violations. </p>

</div>
</div>
<a id="ac6a18a3008fef6ccbd5e00bbe782ebf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a18a3008fef6ccbd5e00bbe782ebf6">&#9670;&nbsp;</a></span>GapType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#ac6a18a3008fef6ccbd5e00bbe782ebf6">dialect::GapType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac6a18a3008fef6ccbd5e00bbe782ebf6a861d9b366d4c6f701fbc59ba9ab7bdda"></a>CENTRE&#160;</td><td class="fielddoc"><p>Gap between the centres of two nodes: </p>
</td></tr>
<tr><td class="fieldname"><a id="ac6a18a3008fef6ccbd5e00bbe782ebf6af8ea4697a0ba147f58031c8f1fcc093a"></a>BDRY&#160;</td><td class="fielddoc"><p>Gap between the opposite boundaries of two nodes: </p>
</td></tr>
</table>

</div>
</div>
<a id="aeffe119eae768555a5403af3e03efd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffe119eae768555a5403af3e03efd44">&#9670;&nbsp;</a></span>LinkShape</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">dialect::LinkShape</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In a 4-planar orthogonal layout, a link has one of six possible shapes, depending on which two of its four sides are the ones where its edges meet it. For example, if one edge enters from the south, and the other from the east, then this link is shaped like the top-left corner of a box. This enum names the six possible configurations. </p>

</div>
</div>
<a id="a2833edc2f859f4d3f596558522748edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2833edc2f859f4d3f596558522748edd">&#9670;&nbsp;</a></span>RouteProcessing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#a2833edc2f859f4d3f596558522748edd">dialect::RouteProcessing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control how much processing should be done on connector routes by the <a class="el" href="structdialect_1_1RoutingAdapter.html" title="Adapter to easily apply libavoid::Routers to libdialect::Graphs. ">RoutingAdapter</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2833edc2f859f4d3f596558522748eddab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>Don't do anything. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2833edc2f859f4d3f596558522748edda921df56002ee5dc960debedc8ae06072"></a>RECORD&#160;</td><td class="fielddoc"><p>Record the connector routes in the Edges, exactly as returned by the Router. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2833edc2f859f4d3f596558522748edda345ddc1a5034d474b5f722a4fad57bcc"></a>REFINE_AND_RECORD&#160;</td><td class="fielddoc"><p>Record the connector routes in the Edges after first doing post-processing to remove extremely small S-bends. </p>
</td></tr>
</table>

</div>
</div>
<a id="a074c3a074f26cf4a8ff4a209d7d61e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074c3a074f26cf4a8ff4a209d7d61e4f">&#9670;&nbsp;</a></span>SepDir</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#a074c3a074f26cf4a8ff4a209d7d61e4f">dialect::SepDir</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a074c3a074f26cf4a8ff4a209d7d61e4fa45ac78bf3d4882ac520f4e7fb08d55c5"></a>EAST&#160;</td><td class="fielddoc"><p>Cardinal constraints imply both a separation and an alignment: </p>
</td></tr>
<tr><td class="fieldname"><a id="a074c3a074f26cf4a8ff4a209d7d61e4fa21507b40c80068eda19865706fdc2403"></a>RIGHT&#160;</td><td class="fielddoc"><p>Lateral constraints imply only a separation: </p>
</td></tr>
</table>

</div>
</div>
<a id="ac3cd2ccfb3d0994fd390d07820510ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cd2ccfb3d0994fd390d07820510ff6">&#9670;&nbsp;</a></span>SepTransform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#ac3cd2ccfb3d0994fd390d07820510ff6">dialect::SepTransform</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac3cd2ccfb3d0994fd390d07820510ff6a86457d7a57e5f9180ace3c1fbbb40be9"></a>ROTATE90CW&#160;</td><td class="fielddoc"><p>Rotate 90 degrees clockwise. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3cd2ccfb3d0994fd390d07820510ff6ab45cdb7fc42321bde747029cbb1e5981"></a>ROTATE90ACW&#160;</td><td class="fielddoc"><p>Rotate 90 degrees anticlockwise. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3cd2ccfb3d0994fd390d07820510ff6a5788ed8b8d0ffb5e041f0404118950be"></a>ROTATE180&#160;</td><td class="fielddoc"><p>Rotate 180 degrees. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3cd2ccfb3d0994fd390d07820510ff6a069749d9f7b6c5bbf05dee2b6c288880"></a>FLIPV&#160;</td><td class="fielddoc"><p>Flip over vertical axis. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3cd2ccfb3d0994fd390d07820510ff6a61027bc7cccbadf48390cac3b40fe673"></a>FLIPH&#160;</td><td class="fielddoc"><p>Flip over horizontal axis. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3cd2ccfb3d0994fd390d07820510ff6a88e29cb8be7080673157702982d19fe5"></a>FLIPMD&#160;</td><td class="fielddoc"><p>Flip over the "main diagonal" i.e. the axis whose slope is positive in the graphics plane. This goes from upper left to lower right, since in the graphics plane the positive y-axis points downward. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3cd2ccfb3d0994fd390d07820510ff6a4706bba6c8743f626350f74367c3f5d0"></a>FLIPOD&#160;</td><td class="fielddoc"><p>Flip over the "off diagonal". </p>
</td></tr>
</table>

</div>
</div>
<a id="a167b9db8fcec7c8227b02856352cb2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167b9db8fcec7c8227b02856352cb2c1">&#9670;&nbsp;</a></span>SepType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#a167b9db8fcec7c8227b02856352cb2c1">dialect::SepType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a167b9db8fcec7c8227b02856352cb2c1ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>No constraint: </p>
</td></tr>
<tr><td class="fieldname"><a id="a167b9db8fcec7c8227b02856352cb2c1a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"><p>An exact separation: </p>
</td></tr>
<tr><td class="fieldname"><a id="a167b9db8fcec7c8227b02856352cb2c1a1add9747ea47fe8dddeba609292fd3a9"></a>INEQ&#160;</td><td class="fielddoc"><p>A minimal separation: </p>
</td></tr>
</table>

</div>
</div>
<a id="a5f240def052ed09e26b2b96feb871cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f240def052ed09e26b2b96feb871cf9">&#9670;&nbsp;</a></span>TreeRoutingType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedialect.html#a5f240def052ed09e26b2b96feb871cf9">dialect::TreeRoutingType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When routing connectors for Trees, the set of allowed connection directions depends on the application.</p>
<p>In, for example, a NORTH-growing tree, an edge between ranks i and i + 1 will always be allowed to connect only to the south (S) port of a node in rank i + 1.</p>
<p>The TreeRoutingType controls the directions allowed for connection to nodes in rank i, as follows:</p>
<p>STRICT: only N is allowed. CORE_ATTACHMENT: N, E, W are allowed for the root node if it has exactly one child and is transversely displaced from its one child; otherwise only N. MONOTONIC: N, E, W are allowed for all nodes on rank i. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad03b2fb8b5aa1df28e32ed5f9f8cf98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03b2fb8b5aa1df28e32ed5f9f8cf98a">&#9670;&nbsp;</a></span>buildGraphFromTglf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdialect_1_1Graph.html">Graph</a>&gt; dialect::buildGraphFromTglf </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> object from TGLF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>An istream containing TGLF.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> built on the given TGLF. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#a6c94d23c1beda10e9881a8cca789aea2">buildGraphFromTglf()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_ad03b2fb8b5aa1df28e32ed5f9f8cf98a_icgraph.png" border="0" usemap="#namespacedialect_ad03b2fb8b5aa1df28e32ed5f9f8cf98a_icgraph" alt=""/></div>
<map name="namespacedialect_ad03b2fb8b5aa1df28e32ed5f9f8cf98a_icgraph" id="namespacedialect_ad03b2fb8b5aa1df28e32ed5f9f8cf98a_icgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a6c94d23c1beda10e9881a8cca789aea2" title="Build a Graph object from TGLF. " alt="" coords="240,5,427,32"/>
</map>
</div>

</div>
</div>
<a id="a6c94d23c1beda10e9881a8cca789aea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c94d23c1beda10e9881a8cca789aea2">&#9670;&nbsp;</a></span>buildGraphFromTglf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph_SP dialect::buildGraphFromTglf </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> object from TGLF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>A string containing TGLF.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> built on the given TGLF. </dd></dl>

<p class="reference">References <a class="el" href="namespacedialect.html#ad03b2fb8b5aa1df28e32ed5f9f8cf98a">buildGraphFromTglf()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a6c94d23c1beda10e9881a8cca789aea2_cgraph.png" border="0" usemap="#namespacedialect_a6c94d23c1beda10e9881a8cca789aea2_cgraph" alt=""/></div>
<map name="namespacedialect_a6c94d23c1beda10e9881a8cca789aea2_cgraph" id="namespacedialect_a6c94d23c1beda10e9881a8cca789aea2_cgraph">
<area shape="rect" id="node2" href="namespacedialect.html#ad03b2fb8b5aa1df28e32ed5f9f8cf98a" title="Build a Graph object from TGLF. " alt="" coords="240,5,427,32"/>
</map>
</div>

</div>
</div>
<a id="a6bda74a96be09f93951039d7d5728877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bda74a96be09f93951039d7d5728877">&#9670;&nbsp;</a></span>buildGraphFromTglfFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdialect_1_1Graph.html">Graph</a>&gt; dialect::buildGraphFromTglfFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> object from a file containing TGLF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Full filesystem path to a file containing TGLF.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> built on the given TGLF. </dd></dl>

</div>
</div>
<a id="a96f57d3ab3a9d4b5e7fc82d40e97385b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f57d3ab3a9d4b5e7fc82d40e97385b">&#9670;&nbsp;</a></span>CompareActiveEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dialect::CompareActiveEvents </td>
          <td>(</td>
          <td class="paramtype">Event *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We need a special function for comparing Events, using a positive tolerance. Here's why. Suppose vertical segment A has its south end at (0, 0), and horizontal segment B has its east end at (0, -0.00000000001). This means that /technically/ A and B intersect. However (<a href="http://xkcd.com/1475/">http://xkcd.com/1475/</a>) you probably don't actually want to treat this as an intersection. The comparison function is designed so that, when the list of active events is sorted, the "close" event for segment A will come /before/ the "sustain" event for segment B, instead of the other way around, as dictated by their exact y-coordinates. This way we will /not/ detect an intersection between A and B. </p>

</div>
</div>
<a id="a05ccc4c149e1b5902ec827bfabd3cf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ccc4c149e1b5902ec827bfabd3cf76">&#9670;&nbsp;</a></span>doHOLA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::doHOLA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dialect::HolaOpts &amp;&#160;</td>
          <td class="paramname"><em>holaOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dialect::Logger *&#160;</td>
          <td class="paramname"><em>logger</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the HOLA layout algorithm to the given <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>. See Steve Kieffer, Tim Dwyer, Kim Marriott, and Michael Wybrow. HOLA: Human-like Orthogonal Network Layout. IEEE Transactions on Visualization and Computer Graphics 22, no. 1 (2016): 349-358. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">G</td><td>The <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> to be laid out. <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> positions are updated in-place. Constraints are set in the <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>'s SepMatrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Options controlling the layout. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">logger</td><td>Optional pointer to a Logger in which to record TGLF for various stages of the layout process. Useful for debugging. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structdialect_1_1OrthoHubLayoutOptions.html#aec2dc1320f704b7f73b52ba5d430073b">dialect::OrthoHubLayoutOptions::avoidFlatTriangles</a>, <a class="el" href="namespacedialect.html#a78c126f4a90d9e38c4b00e85db20f8c7">buildAllChainsInGraph()</a>, <a class="el" href="classdialect_1_1ACALayout.html#a0fc4364e821983142e55e978e33e29a2">dialect::ACALayout::createAlignments()</a>, <a class="el" href="namespacedialect.html#a0e008284e07fda0a6c7e60e1d501dfa9">doNearAlignments()</a>, <a class="el" href="classdialect_1_1Graph.html#a0dbf008d97d5a6ad814778217d2da948">dialect::Graph::getIEL()</a>, <a class="el" href="classdialect_1_1Graph.html#abce986e93e2c1dd090a9cdfd924e0c99">dialect::Graph::getNumEdges()</a>, <a class="el" href="classdialect_1_1Graph.html#af941c70fd0d10fd6cad07f61434aec93">dialect::Graph::getNumNodes()</a>, <a class="el" href="structdialect_1_1BoundingBox.html#a0c3a42869c020255f63dfce1a891066d">dialect::BoundingBox::h()</a>, <a class="el" href="classdialect_1_1OrthoHubLayout.html#a0b9a6aa806f4ccf26b448aa67d7fed95">dialect::OrthoHubLayout::layout()</a>, <a class="el" href="structdialect_1_1ColaOptions.html#a32b67ff7ddf0999a217ac86c5724964a">dialect::ColaOptions::logger</a>, <a class="el" href="structdialect_1_1ColaOptions.html#a918709803d7e7a33dfffd7ae288646c9">dialect::ColaOptions::nodeClusters</a>, <a class="el" href="namespaceAvoid.html#abc707ccbd6a0a7c29c124162c864ca05af7be85399d751dd52483038192cfaba2">Avoid::nudgeOrthogonalSegmentsConnectedToShapes</a>, <a class="el" href="namespaceAvoid.html#abc707ccbd6a0a7c29c124162c864ca05abb9b97f0edc1dd472c1a38633a340c1f">Avoid::nudgeSharedPathsWithCommonEndPoint</a>, <a class="el" href="namespaceAvoid.html#a8b398574e5b64951b7f23a36a1cdfcf4a4b104d4d6ef8bcf22994808b936e83ff">Avoid::OrthogonalRouting</a>, <a class="el" href="classdialect_1_1Graph.html#a955bdc479f10b59c0b53e3cf1e8f1aeb">dialect::Graph::padAllNodes()</a>, <a class="el" href="namespacedialect.html#a29b1d1583bf8668dde5e0252a2205eb1">peel()</a>, <a class="el" href="classdialect_1_1OrthoPlanariser.html#a9bd66fa7b2d08e447741fdbc590d1167">dialect::OrthoPlanariser::planarise()</a>, <a class="el" href="structdialect_1_1ColaOptions.html#a3d825401e1cdd3956e567403bdf7b6cf">dialect::ColaOptions::preventOverlaps</a>, <a class="el" href="namespacedialect.html#a9d325ef46ea3385428712f16fedf71ef">reattachTrees()</a>, <a class="el" href="structdialect_1_1RoutingAdapter.html#a017c2b77ed6ad722dc6e18435969a58b">dialect::RoutingAdapter::route()</a>, <a class="el" href="classdialect_1_1LeaflessOrthoRouter.html#af58e911020f19a144303fc01e5b8c35e">dialect::LeaflessOrthoRouter::route()</a>, <a class="el" href="structdialect_1_1RoutingAdapter.html#ad498aae40036ee2c318ded7cc17dcb8c">dialect::RoutingAdapter::router</a>, <a class="el" href="classAvoid_1_1Router.html#a09f057f6d101f010588c9022893c9ac1">Avoid::Router::setRoutingOption()</a>, <a class="el" href="structdialect_1_1ColaOptions.html#a75264328d9a9a5e4e33446acf04d5452">dialect::ColaOptions::solidEdgeExemptions</a>, <a class="el" href="structdialect_1_1ColaOptions.html#a47dc9df69a42da1201685d870b153080">dialect::ColaOptions::solidifyAlignedEdges</a>, <a class="el" href="namespacedialect.html#a7fdbc3f53251706e91936da1109bb644">string_format()</a>, <a class="el" href="classdialect_1_1ACALayout.html#ad8987f21eba0008c7f43ecbbc6b961fd">dialect::ACALayout::updateGraph()</a>, <a class="el" href="structdialect_1_1ColaOptions.html#aacb645ef8413519cf70de451cffe1081">dialect::ColaOptions::useMajorization</a>, <a class="el" href="structdialect_1_1ColaOptions.html#aa122527d70c26640aeba58efff242b81">dialect::ColaOptions::useNeighbourStress</a>, <a class="el" href="structdialect_1_1BoundingBox.html#a467c0c9f4464e66abdc2eb342f3f7c57">dialect::BoundingBox::w()</a>, <a class="el" href="namespacevpsc.html#a498ea1e279ae35b8aa2edac29a3ebc17a229d6184c9e0791207bce362fa9e2d3b">vpsc::XDIM</a>, and <a class="el" href="namespacevpsc.html#a498ea1e279ae35b8aa2edac29a3ebc17aacd8ea78c63f9bd68e4b4a5aad0761b3">vpsc::YDIM</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a">doHOLA()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_cgraph.png" border="0" usemap="#namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_cgraph" alt=""/></div>
<map name="namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_cgraph" id="namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_cgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a78c126f4a90d9e38c4b00e85db20f8c7" title="Convenience method to build all the chains and cycles in a graph. " alt="" coords="189,5,353,47"/>
<area shape="rect" id="node3" href="classdialect_1_1ACALayout.html#a0fc4364e821983142e55e978e33e29a2" title="Creates alignments. " alt="" coords="203,71,339,112"/>
<area shape="rect" id="node4" href="namespacedialect.html#a0e008284e07fda0a6c7e60e1d501dfa9" title="Look for nodes that are nearly aligned, and try to align them. " alt="" coords="182,137,359,163"/>
<area shape="rect" id="node5" href="classdialect_1_1Graph.html#a0dbf008d97d5a6ad814778217d2da948" title="Read the ideal edge length of this Graph. " alt="" coords="195,187,346,214"/>
<area shape="rect" id="node6" href="classdialect_1_1Graph.html#abce986e93e2c1dd090a9cdfd924e0c99" title="Say how many Edges there are in this Graph. " alt="" coords="172,238,369,265"/>
<area shape="rect" id="node7" href="classdialect_1_1Graph.html#af941c70fd0d10fd6cad07f61434aec93" title="Say how many Nodes there are in this Graph. " alt="" coords="172,289,369,315"/>
<area shape="rect" id="node8" href="structdialect_1_1BoundingBox.html#a0c3a42869c020255f63dfce1a891066d" title="Get the height of the box. " alt="" coords="189,339,352,366"/>
<area shape="rect" id="node9" href="classdialect_1_1OrthoHubLayout.html#a0b9a6aa806f4ccf26b448aa67d7fed95" title="Try to orthogonalise hubs. " alt="" coords="188,456,353,497"/>
<area shape="rect" id="node11" href="namespacedialect.html#a7fdbc3f53251706e91936da1109bb644" title="String formatting. " alt="" coords="458,522,603,549"/>
<area shape="rect" id="node13" href="classdialect_1_1Graph.html#a955bdc479f10b59c0b53e3cf1e8f1aeb" title="Add padding to all ndoes. " alt="" coords="177,755,365,782"/>
<area shape="rect" id="node14" href="namespacedialect.html#a29b1d1583bf8668dde5e0252a2205eb1" title="Perform the &quot;peeling&quot; process, in which the exterior trees are removed from the given Graph..." alt="" coords="224,1090,317,1117"/>
<area shape="rect" id="node31" href="classdialect_1_1OrthoPlanariser.html#a9bd66fa7b2d08e447741fdbc590d1167" title="Compute a planarisation of the given Graph. " alt="" coords="190,1141,351,1183"/>
<area shape="rect" id="node32" href="namespacedialect.html#a9d325ef46ea3385428712f16fedf71ef" title="Given a planar orthogonal core, and the corresponding Trees (as resulting from the peeling process)..." alt="" coords="195,573,346,599"/>
<area shape="rect" id="node34" href="structdialect_1_1RoutingAdapter.html#a017c2b77ed6ad722dc6e18435969a58b" title="Do the routing. " alt="" coords="191,624,351,665"/>
<area shape="rect" id="node37" href="classdialect_1_1LeaflessOrthoRouter.html#af58e911020f19a144303fc01e5b8c35e" title="Do the routing. " alt="" coords="175,689,366,731"/>
<area shape="rect" id="node55" href="classAvoid_1_1Router.html#a09f057f6d101f010588c9022893c9ac1" title="Turn specific routing options on or off. " alt="" coords="184,1207,357,1248"/>
<area shape="rect" id="node56" href="classdialect_1_1ACALayout.html#ad8987f21eba0008c7f43ecbbc6b961fd" title="For forward compatibility (i.e. with Graphs), we offer a convenience method to update the Graph (when..." alt="" coords="203,391,339,432"/>
<area shape="rect" id="node57" href="structdialect_1_1BoundingBox.html#a467c0c9f4464e66abdc2eb342f3f7c57" title="Get the width of the box. " alt="" coords="189,1273,353,1299"/>
<area shape="rect" id="node10" href="classdialect_1_1ACALayout.html#ad64d1f3c84dcd313ab48e57f4788b026" title="Creates all the requested alignments, or none if any is infeasible. " alt="" coords="449,456,612,497"/>
<area shape="rect" id="node12" href="classdialect_1_1ACALayout.html#afb9467554d9931aee36e5825d4a574fb" title="Update the SepMatrix of the Graph on which this ACALayout was built (if any). " alt="" coords="463,391,599,432"/>
<area shape="rect" id="node15" href="structdialect_1_1NodeBuckets.html#a1058d0a33849b95a75ea5ee17ba979a4" title="Return a copy of the bucket of leaves, and clear the latter. " alt="" coords="457,1217,604,1259"/>
<area shape="rect" id="node16" href="namespacedialect.html#a7e4dc6aea10cd3c086f57c1be3960aeb" title="Make a Stem object to represent each leaf. " alt="" coords="425,1283,637,1310"/>
<area shape="rect" id="node17" href="structdialect_1_1NodeBuckets.html#a7cba81f7da5c12fe1cad7c3b5173e556" title="Sever the given Nodes from our Graph. " alt="" coords="457,1335,604,1376"/>
<area shape="rect" id="node25" href="classdialect_1_1Graph.html#ac4e10d13edd049dd2da80ea986b76fe9" title="Say whether the Graph is empty, meaning that it has no Nodes. " alt="" coords="451,1065,611,1091"/>
<area shape="rect" id="node26" href="namespacedialect.html#a348cb1a0dfe6202d4ff711029a4ccf8e" title="Mark as &quot;root&quot; the PeeledNode having largest serial number. " alt="" coords="445,1115,616,1142"/>
<area shape="rect" id="node28" href="classdialect_1_1Graph.html#a0adf4a0dc63a42b8196f3864d1d31e04" title="Look up a Node by ID. " alt="" coords="714,1221,877,1247"/>
<area shape="rect" id="node18" href="classdialect_1_1Graph.html#ad6434fe1d4f4fce48f5cd88bb943606c" title="Like severNode but also returns a vector of all Nodes that were neighbours before severing..." alt="" coords="707,1393,884,1435"/>
<area shape="rect" id="node23" href="structdialect_1_1NodeBuckets.html#a39f69438d390511f0a13edab602adcad" title="Move a node from one bucket to another. " alt="" coords="722,1276,869,1317"/>
<area shape="rect" id="node24" href="classdialect_1_1Graph.html#a6e23356b35518e9fd3ca93e3b6dd555a" title="Remove several Nodes from this Graph. " alt="" coords="697,1342,893,1369"/>
<area shape="rect" id="node19" href="classdialect_1_1Node.html#ab82a623cf2c0d97bfb3206b1b5d656f3" title="Read&#45;only access to this Node&#39;s lookup map for Edges by their ID. " alt="" coords="947,1426,1147,1453"/>
<area shape="rect" id="node20" href="classdialect_1_1Graph.html#a86f8762c5ddfdad4c934285da5bd4933" title="Sever an Edge in this Graph. " alt="" coords="959,1375,1135,1402"/>
<area shape="rect" id="node21" href="classdialect_1_1Edge.html#a04fbe3f536a380fc6d70bcb09728ca08" title="&quot;Sever&quot; this Edge, i.e. remove it from the Nodes to which it is attached. " alt="" coords="1197,1401,1335,1427"/>
<area shape="rect" id="node22" href="classdialect_1_1Edge.html#ab3e603f70b854af7f69b12bcb7a06de4" title="Access the unique ID of this instance. " alt="" coords="1207,1350,1325,1377"/>
<area shape="rect" id="node27" href="classdialect_1_1Graph.html#a5467080616423cac88b67242aedf0949" title="Read&#45;only access to this Graph&#39;s lookup map for Nodes by their ID. " alt="" coords="692,1170,899,1197"/>
<area shape="rect" id="node29" href="classdialect_1_1Node.html#a5463ea8526de6f00794156ae79f8226b" title="Say whether this Node is a root. This is useful when working with trees, and can be safely ignored wh..." alt="" coords="713,1119,877,1146"/>
<area shape="rect" id="node30" href="classdialect_1_1Node.html#ac9a5e3dbde4ca97e31486de74305f101" title="Check whether this Node has been marked as being a root. This is useful when working with trees..." alt="" coords="974,1119,1119,1146"/>
<area shape="rect" id="node33" href="namespacedialect.html#a74c07364fd697fc53a40c3dd7099ed95" title="Choose the best TreePlacement from among a list of alternatives. " alt="" coords="431,573,631,599"/>
<area shape="rect" id="node35" href="classAvoid_1_1Router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently. " alt="" coords="417,690,644,717"/>
<area shape="rect" id="node36" href="structdialect_1_1RoutingAdapter.html#a72d4d8abc45334d96c84e6cfba985ffe" title="Record the routes in the Edges. " alt="" coords="451,624,611,665"/>
<area shape="rect" id="node38" href="classAvoid_1_1Router.html#a458aae2d6447e0958e4916a8c29bbb47" title="Generates an SVG file containing debug output and code that can be used to regenerate the instance..." alt="" coords="432,859,629,900"/>
<area shape="rect" id="node53" href="classAvoid_1_1ConnRef.html#a45ab41f9847a610ba17a326cd05cb266" title="Sets just a new source endpoint for this connector. " alt="" coords="439,741,622,783"/>
<area shape="rect" id="node54" href="classAvoid_1_1ConnRef.html#a7b216c9aa42811f1f2786adbda84f02e" title="Sets just a new destination endpoint for this connector. " alt="" coords="421,807,641,834"/>
<area shape="rect" id="node39" href="classAvoid_1_1Polygon.html#ab2772d0cf1d0aad817a9814e20fce5ab" title="Returns a specific point in the polygon. " alt="" coords="982,706,1111,733"/>
<area shape="rect" id="node40" href="classAvoid_1_1Polygon.html#a2f9e9c8c78407eefbde944e663d9711e" title="Returns the number of points in this polygon. " alt="" coords="1195,757,1337,783"/>
<area shape="rect" id="node41" href="classAvoid_1_1ReferencingPolygon.html#a168bb0af7ba4147861f6b326d088da71" title="Returns a specific point in the polygon. " alt="" coords="695,765,896,791"/>
<area shape="rect" id="node42" href="classAvoid_1_1ReferencingPolygon.html#a1dde474f3703dfe854768d5857a94067" title="Returns the number of points in this polygon. " alt="" coords="955,808,1138,849"/>
<area shape="rect" id="node43" href="classAvoid_1_1Polygon.html#a35ab2aa804cc40ae127e0641e254d268" title="Returns a curved approximation of this multi&#45;segment PolyLine, with the corners replaced by smooth Be..." alt="" coords="693,866,898,893"/>
<area shape="rect" id="node45" href="classAvoid_1_1ConnRef.html#ab7462cd69bd1d2c4dd318119558b4a94" title="Returns a reference to the current display version of the route for the connector. " alt="" coords="695,917,895,943"/>
<area shape="rect" id="node46" href="classAvoid_1_1Polygon.html#a477d0e8e93509d7955d1f4b4ca0abb0d" title="Returns true if this polygon is empty. " alt="" coords="969,975,1124,1002"/>
<area shape="rect" id="node47" href="classAvoid_1_1ClusterRef.html#a7a25b0c34cdad039906693265a9caac8" title="Returns the ID of this cluster. " alt="" coords="723,1018,867,1045"/>
<area shape="rect" id="node48" href="classAvoid_1_1ConnRef.html#a053841a1fdef00b1e90f20f563e1c259" title="Returns the ID of this connector. " alt="" coords="729,1069,862,1095"/>
<area shape="rect" id="node49" href="classAvoid_1_1ClusterRef.html#acd1fa20b079253d53d27abf50d2a8933" title="Returns a reference to the polygon boundary of this cluster. " alt="" coords="729,416,862,457"/>
<area shape="rect" id="node50" href="classAvoid_1_1JunctionRef.html#a5b376e38102c5e4c9b625be21a9e46d5" title="Returns a recommended position for the junction based on improving hyperedge routes. This value will be set during routing when the improveHyperedgeRoutesMovingJunctions router option is set (the default). " alt="" coords="714,481,877,523"/>
<area shape="rect" id="node51" href="classAvoid_1_1ClusterRef.html#af7877b59ea4cb2939047f785382f8008" title="Returns a reference to the rectangular boundary of this cluster. " alt="" coords="727,547,864,588"/>
<area shape="rect" id="node52" href="classAvoid_1_1ConnRef.html#a0d90245fbe772d30723bd578efa3a45d" title="Returns a reference to the current raw &quot;debug&quot; route for the connector. " alt="" coords="719,613,872,639"/>
<area shape="rect" id="node44" href="classAvoid_1_1Polygon.html#a2d3a0deb96bbff214b7035e481f0f0e8" title="Returns a simplified Polyline, where all collinear line segments have been collapsed down into single..." alt="" coords="965,925,1128,951"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_icgraph.png" border="0" usemap="#namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_icgraph" alt=""/></div>
<map name="namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_icgraph" id="namespacedialect_a05ccc4c149e1b5902ec827bfabd3cf76_icgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a" title="Convenience function to do HOLA layout with default options. " alt="" coords="172,5,291,32"/>
</map>
</div>

</div>
</div>
<a id="a24766038e1a9ccd99997ea31c42b432a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24766038e1a9ccd99997ea31c42b432a">&#9670;&nbsp;</a></span>doHOLA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::doHOLA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to do HOLA layout with default options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">G</td><td>The <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> to be laid out. <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> positions are updated in-place. Constraints are set in the <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>'s SepMatrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76">doHOLA()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a24766038e1a9ccd99997ea31c42b432a_cgraph.png" border="0" usemap="#namespacedialect_a24766038e1a9ccd99997ea31c42b432a_cgraph" alt=""/></div>
<map name="namespacedialect_a24766038e1a9ccd99997ea31c42b432a_cgraph" id="namespacedialect_a24766038e1a9ccd99997ea31c42b432a_cgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76" title="Apply the HOLA layout algorithm to the given Graph. See Steve Kieffer, Tim Dwyer, Kim Marriott..." alt="" coords="172,493,291,519"/>
<area shape="rect" id="node3" href="namespacedialect.html#a78c126f4a90d9e38c4b00e85db20f8c7" title="Convenience method to build all the chains and cycles in a graph. " alt="" coords="355,5,519,47"/>
<area shape="rect" id="node4" href="classdialect_1_1ACALayout.html#a0fc4364e821983142e55e978e33e29a2" title="Creates alignments. " alt="" coords="369,71,505,112"/>
<area shape="rect" id="node5" href="namespacedialect.html#a0e008284e07fda0a6c7e60e1d501dfa9" title="Look for nodes that are nearly aligned, and try to align them. " alt="" coords="349,137,526,163"/>
<area shape="rect" id="node6" href="classdialect_1_1Graph.html#a0dbf008d97d5a6ad814778217d2da948" title="Read the ideal edge length of this Graph. " alt="" coords="362,187,513,214"/>
<area shape="rect" id="node7" href="classdialect_1_1Graph.html#abce986e93e2c1dd090a9cdfd924e0c99" title="Say how many Edges there are in this Graph. " alt="" coords="339,238,536,265"/>
<area shape="rect" id="node8" href="classdialect_1_1Graph.html#af941c70fd0d10fd6cad07f61434aec93" title="Say how many Nodes there are in this Graph. " alt="" coords="339,289,536,315"/>
<area shape="rect" id="node9" href="structdialect_1_1BoundingBox.html#a0c3a42869c020255f63dfce1a891066d" title="Get the height of the box. " alt="" coords="356,339,519,366"/>
<area shape="rect" id="node10" href="classdialect_1_1OrthoHubLayout.html#a0b9a6aa806f4ccf26b448aa67d7fed95" title="Try to orthogonalise hubs. " alt="" coords="355,456,520,497"/>
<area shape="rect" id="node12" href="namespacedialect.html#a7fdbc3f53251706e91936da1109bb644" title="String formatting. " alt="" coords="625,522,770,549"/>
<area shape="rect" id="node14" href="classdialect_1_1Graph.html#a955bdc479f10b59c0b53e3cf1e8f1aeb" title="Add padding to all ndoes. " alt="" coords="343,755,531,782"/>
<area shape="rect" id="node15" href="namespacedialect.html#a29b1d1583bf8668dde5e0252a2205eb1" title="Perform the &quot;peeling&quot; process, in which the exterior trees are removed from the given Graph..." alt="" coords="391,1090,484,1117"/>
<area shape="rect" id="node32" href="classdialect_1_1OrthoPlanariser.html#a9bd66fa7b2d08e447741fdbc590d1167" title="Compute a planarisation of the given Graph. " alt="" coords="357,1141,518,1183"/>
<area shape="rect" id="node33" href="namespacedialect.html#a9d325ef46ea3385428712f16fedf71ef" title="Given a planar orthogonal core, and the corresponding Trees (as resulting from the peeling process)..." alt="" coords="362,573,513,599"/>
<area shape="rect" id="node35" href="structdialect_1_1RoutingAdapter.html#a017c2b77ed6ad722dc6e18435969a58b" title="Do the routing. " alt="" coords="357,624,517,665"/>
<area shape="rect" id="node38" href="classdialect_1_1LeaflessOrthoRouter.html#af58e911020f19a144303fc01e5b8c35e" title="Do the routing. " alt="" coords="342,689,533,731"/>
<area shape="rect" id="node56" href="classAvoid_1_1Router.html#a09f057f6d101f010588c9022893c9ac1" title="Turn specific routing options on or off. " alt="" coords="351,1207,524,1248"/>
<area shape="rect" id="node57" href="classdialect_1_1ACALayout.html#ad8987f21eba0008c7f43ecbbc6b961fd" title="For forward compatibility (i.e. with Graphs), we offer a convenience method to update the Graph (when..." alt="" coords="369,391,505,432"/>
<area shape="rect" id="node58" href="structdialect_1_1BoundingBox.html#a467c0c9f4464e66abdc2eb342f3f7c57" title="Get the width of the box. " alt="" coords="355,1273,519,1299"/>
<area shape="rect" id="node11" href="classdialect_1_1ACALayout.html#ad64d1f3c84dcd313ab48e57f4788b026" title="Creates all the requested alignments, or none if any is infeasible. " alt="" coords="616,456,779,497"/>
<area shape="rect" id="node13" href="classdialect_1_1ACALayout.html#afb9467554d9931aee36e5825d4a574fb" title="Update the SepMatrix of the Graph on which this ACALayout was built (if any). " alt="" coords="629,391,765,432"/>
<area shape="rect" id="node16" href="structdialect_1_1NodeBuckets.html#a1058d0a33849b95a75ea5ee17ba979a4" title="Return a copy of the bucket of leaves, and clear the latter. " alt="" coords="624,1217,771,1259"/>
<area shape="rect" id="node17" href="namespacedialect.html#a7e4dc6aea10cd3c086f57c1be3960aeb" title="Make a Stem object to represent each leaf. " alt="" coords="591,1283,803,1310"/>
<area shape="rect" id="node18" href="structdialect_1_1NodeBuckets.html#a7cba81f7da5c12fe1cad7c3b5173e556" title="Sever the given Nodes from our Graph. " alt="" coords="624,1335,771,1376"/>
<area shape="rect" id="node26" href="classdialect_1_1Graph.html#ac4e10d13edd049dd2da80ea986b76fe9" title="Say whether the Graph is empty, meaning that it has no Nodes. " alt="" coords="617,1065,777,1091"/>
<area shape="rect" id="node27" href="namespacedialect.html#a348cb1a0dfe6202d4ff711029a4ccf8e" title="Mark as &quot;root&quot; the PeeledNode having largest serial number. " alt="" coords="612,1115,783,1142"/>
<area shape="rect" id="node29" href="classdialect_1_1Graph.html#a0adf4a0dc63a42b8196f3864d1d31e04" title="Look up a Node by ID. " alt="" coords="881,1221,1043,1247"/>
<area shape="rect" id="node19" href="classdialect_1_1Graph.html#ad6434fe1d4f4fce48f5cd88bb943606c" title="Like severNode but also returns a vector of all Nodes that were neighbours before severing..." alt="" coords="873,1393,1051,1435"/>
<area shape="rect" id="node24" href="structdialect_1_1NodeBuckets.html#a39f69438d390511f0a13edab602adcad" title="Move a node from one bucket to another. " alt="" coords="889,1276,1035,1317"/>
<area shape="rect" id="node25" href="classdialect_1_1Graph.html#a6e23356b35518e9fd3ca93e3b6dd555a" title="Remove several Nodes from this Graph. " alt="" coords="864,1342,1060,1369"/>
<area shape="rect" id="node20" href="classdialect_1_1Node.html#ab82a623cf2c0d97bfb3206b1b5d656f3" title="Read&#45;only access to this Node&#39;s lookup map for Edges by their ID. " alt="" coords="1113,1426,1313,1453"/>
<area shape="rect" id="node21" href="classdialect_1_1Graph.html#a86f8762c5ddfdad4c934285da5bd4933" title="Sever an Edge in this Graph. " alt="" coords="1125,1375,1301,1402"/>
<area shape="rect" id="node22" href="classdialect_1_1Edge.html#a04fbe3f536a380fc6d70bcb09728ca08" title="&quot;Sever&quot; this Edge, i.e. remove it from the Nodes to which it is attached. " alt="" coords="1363,1401,1502,1427"/>
<area shape="rect" id="node23" href="classdialect_1_1Edge.html#ab3e603f70b854af7f69b12bcb7a06de4" title="Access the unique ID of this instance. " alt="" coords="1374,1350,1491,1377"/>
<area shape="rect" id="node28" href="classdialect_1_1Graph.html#a5467080616423cac88b67242aedf0949" title="Read&#45;only access to this Graph&#39;s lookup map for Nodes by their ID. " alt="" coords="859,1170,1065,1197"/>
<area shape="rect" id="node30" href="classdialect_1_1Node.html#a5463ea8526de6f00794156ae79f8226b" title="Say whether this Node is a root. This is useful when working with trees, and can be safely ignored wh..." alt="" coords="880,1119,1044,1146"/>
<area shape="rect" id="node31" href="classdialect_1_1Node.html#ac9a5e3dbde4ca97e31486de74305f101" title="Check whether this Node has been marked as being a root. This is useful when working with trees..." alt="" coords="1141,1119,1286,1146"/>
<area shape="rect" id="node34" href="namespacedialect.html#a74c07364fd697fc53a40c3dd7099ed95" title="Choose the best TreePlacement from among a list of alternatives. " alt="" coords="597,573,797,599"/>
<area shape="rect" id="node36" href="classAvoid_1_1Router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently. " alt="" coords="584,690,811,717"/>
<area shape="rect" id="node37" href="structdialect_1_1RoutingAdapter.html#a72d4d8abc45334d96c84e6cfba985ffe" title="Record the routes in the Edges. " alt="" coords="617,624,777,665"/>
<area shape="rect" id="node39" href="classAvoid_1_1Router.html#a458aae2d6447e0958e4916a8c29bbb47" title="Generates an SVG file containing debug output and code that can be used to regenerate the instance..." alt="" coords="599,859,796,900"/>
<area shape="rect" id="node54" href="classAvoid_1_1ConnRef.html#a45ab41f9847a610ba17a326cd05cb266" title="Sets just a new source endpoint for this connector. " alt="" coords="606,741,789,783"/>
<area shape="rect" id="node55" href="classAvoid_1_1ConnRef.html#a7b216c9aa42811f1f2786adbda84f02e" title="Sets just a new destination endpoint for this connector. " alt="" coords="587,807,807,834"/>
<area shape="rect" id="node40" href="classAvoid_1_1Polygon.html#ab2772d0cf1d0aad817a9814e20fce5ab" title="Returns a specific point in the polygon. " alt="" coords="1149,706,1278,733"/>
<area shape="rect" id="node41" href="classAvoid_1_1Polygon.html#a2f9e9c8c78407eefbde944e663d9711e" title="Returns the number of points in this polygon. " alt="" coords="1361,757,1504,783"/>
<area shape="rect" id="node42" href="classAvoid_1_1ReferencingPolygon.html#a168bb0af7ba4147861f6b326d088da71" title="Returns a specific point in the polygon. " alt="" coords="861,765,1063,791"/>
<area shape="rect" id="node43" href="classAvoid_1_1ReferencingPolygon.html#a1dde474f3703dfe854768d5857a94067" title="Returns the number of points in this polygon. " alt="" coords="1122,808,1305,849"/>
<area shape="rect" id="node44" href="classAvoid_1_1Polygon.html#a35ab2aa804cc40ae127e0641e254d268" title="Returns a curved approximation of this multi&#45;segment PolyLine, with the corners replaced by smooth Be..." alt="" coords="859,866,1065,893"/>
<area shape="rect" id="node46" href="classAvoid_1_1ConnRef.html#ab7462cd69bd1d2c4dd318119558b4a94" title="Returns a reference to the current display version of the route for the connector. " alt="" coords="862,917,1062,943"/>
<area shape="rect" id="node47" href="classAvoid_1_1Polygon.html#a477d0e8e93509d7955d1f4b4ca0abb0d" title="Returns true if this polygon is empty. " alt="" coords="1136,975,1291,1002"/>
<area shape="rect" id="node48" href="classAvoid_1_1ClusterRef.html#a7a25b0c34cdad039906693265a9caac8" title="Returns the ID of this cluster. " alt="" coords="890,1018,1034,1045"/>
<area shape="rect" id="node49" href="classAvoid_1_1ConnRef.html#a053841a1fdef00b1e90f20f563e1c259" title="Returns the ID of this connector. " alt="" coords="895,1069,1029,1095"/>
<area shape="rect" id="node50" href="classAvoid_1_1ClusterRef.html#acd1fa20b079253d53d27abf50d2a8933" title="Returns a reference to the polygon boundary of this cluster. " alt="" coords="895,416,1029,457"/>
<area shape="rect" id="node51" href="classAvoid_1_1JunctionRef.html#a5b376e38102c5e4c9b625be21a9e46d5" title="Returns a recommended position for the junction based on improving hyperedge routes. This value will be set during routing when the improveHyperedgeRoutesMovingJunctions router option is set (the default). " alt="" coords="881,481,1043,523"/>
<area shape="rect" id="node52" href="classAvoid_1_1ClusterRef.html#af7877b59ea4cb2939047f785382f8008" title="Returns a reference to the rectangular boundary of this cluster. " alt="" coords="893,547,1031,588"/>
<area shape="rect" id="node53" href="classAvoid_1_1ConnRef.html#a0d90245fbe772d30723bd578efa3a45d" title="Returns a reference to the current raw &quot;debug&quot; route for the connector. " alt="" coords="885,613,1039,639"/>
<area shape="rect" id="node45" href="classAvoid_1_1Polygon.html#a2d3a0deb96bbff214b7035e481f0f0e8" title="Returns a simplified Polyline, where all collinear line segments have been collapsed down into single..." alt="" coords="1132,925,1295,951"/>
</map>
</div>

</div>
</div>
<a id="a0e008284e07fda0a6c7e60e1d501dfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e008284e07fda0a6c7e60e1d501dfa9">&#9670;&nbsp;</a></span>doNearAlignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dialect::doNearAlignments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dialect::AlignmentTable &amp;&#160;</td>
          <td class="paramname"><em>atab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dialect::NodesById &amp;&#160;</td>
          <td class="paramname"><em>ignore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dialect::HolaOpts &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reattempt</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for nodes that are nearly aligned, and try to align them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">graph</td><td>The <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> whose nodes are to be aligned, and in whose SepMatrix alignments should be recorded when made. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">atab</td><td>An AlignmentTable for the given <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>HolaOpts object to set parameters for the process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reattempt</td><td>Set true for a more aggressive process that reattempts alignments even after they have been marked infeasible (in case other changes in the meantime might have made them now feasible). Default: false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of successful alignments. </dd></dl>

<p class="reference">References <a class="el" href="namespacevpsc.html#a498ea1e279ae35b8aa2edac29a3ebc17a229d6184c9e0791207bce362fa9e2d3b">vpsc::XDIM</a>, and <a class="el" href="namespacevpsc.html#a498ea1e279ae35b8aa2edac29a3ebc17aacd8ea78c63f9bd68e4b4a5aad0761b3">vpsc::YDIM</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76">doHOLA()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a0e008284e07fda0a6c7e60e1d501dfa9_icgraph.png" border="0" usemap="#namespacedialect_a0e008284e07fda0a6c7e60e1d501dfa9_icgraph" alt=""/></div>
<map name="namespacedialect_a0e008284e07fda0a6c7e60e1d501dfa9_icgraph" id="namespacedialect_a0e008284e07fda0a6c7e60e1d501dfa9_icgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76" title="Apply the HOLA layout algorithm to the given Graph. See Steve Kieffer, Tim Dwyer, Kim Marriott..." alt="" coords="231,5,349,32"/>
<area shape="rect" id="node3" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a" title="Convenience function to do HOLA layout with default options. " alt="" coords="397,5,516,32"/>
</map>
</div>

</div>
</div>
<a id="a348cb1a0dfe6202d4ff711029a4ccf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348cb1a0dfe6202d4ff711029a4ccf8e">&#9670;&nbsp;</a></span>identifyRootNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PeeledNode_SP dialect::identifyRootNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdialect_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark as "root" the <a class="el" href="classdialect_1_1PeeledNode.html" title="A PeeledNode is a type of GhostNode, used in the peeling process. ">PeeledNode</a> having largest serial number. </p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> must contain only PeeledNodes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classdialect_1_1PeeledNode.html" title="A PeeledNode is a type of GhostNode, used in the peeling process. ">PeeledNode</a> identified as root. </dd></dl>

<p class="reference">References <a class="el" href="classdialect_1_1Graph.html#a0adf4a0dc63a42b8196f3864d1d31e04">dialect::Graph::getNode()</a>, <a class="el" href="classdialect_1_1Graph.html#a5467080616423cac88b67242aedf0949">dialect::Graph::getNodeLookup()</a>, and <a class="el" href="classdialect_1_1Node.html#a5463ea8526de6f00794156ae79f8226b">dialect::Node::setIsRoot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#a29b1d1583bf8668dde5e0252a2205eb1">peel()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_cgraph.png" border="0" usemap="#namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_cgraph" alt=""/></div>
<map name="namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_cgraph" id="namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Graph.html#a0adf4a0dc63a42b8196f3864d1d31e04" title="Look up a Node by ID. " alt="" coords="246,5,409,32"/>
<area shape="rect" id="node3" href="classdialect_1_1Graph.html#a5467080616423cac88b67242aedf0949" title="Read&#45;only access to this Graph&#39;s lookup map for Nodes by their ID. " alt="" coords="224,56,431,83"/>
<area shape="rect" id="node4" href="classdialect_1_1Node.html#a5463ea8526de6f00794156ae79f8226b" title="Say whether this Node is a root. This is useful when working with trees, and can be safely ignored wh..." alt="" coords="245,107,409,133"/>
<area shape="rect" id="node5" href="classdialect_1_1Node.html#ac9a5e3dbde4ca97e31486de74305f101" title="Check whether this Node has been marked as being a root. This is useful when working with trees..." alt="" coords="479,107,624,133"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_icgraph.png" border="0" usemap="#namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_icgraph" alt=""/></div>
<map name="namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_icgraph" id="namespacedialect_a348cb1a0dfe6202d4ff711029a4ccf8e_icgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a29b1d1583bf8668dde5e0252a2205eb1" title="Perform the &quot;peeling&quot; process, in which the exterior trees are removed from the given Graph..." alt="" coords="224,5,317,32"/>
<area shape="rect" id="node3" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76" title="Apply the HOLA layout algorithm to the given Graph. See Steve Kieffer, Tim Dwyer, Kim Marriott..." alt="" coords="365,5,484,32"/>
<area shape="rect" id="node4" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a" title="Convenience function to do HOLA layout with default options. " alt="" coords="532,5,651,32"/>
</map>
</div>

</div>
</div>
<a id="a67f558d7aec6b04a1f52fde6c4796b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f558d7aec6b04a1f52fde6c4796b77">&#9670;&nbsp;</a></span>logically_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dialect::logically_equal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error_factor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tolerant equality test for doubles. Generates principled value for tolerance. </p>
<dl class="section note"><dt>Note</dt><dd>Thanks to: <a href="https://stackoverflow.com/a/4010279">https://stackoverflow.com/a/4010279</a> </dd></dl>

</div>
</div>
<a id="ab13e7be712ac2f35c54fcc9e338d7902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13e7be712ac2f35c54fcc9e338d7902">&#9670;&nbsp;</a></span>lookupMinimalBendSeqs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a> &gt; &gt; dialect::lookupMinimalBendSeqs </td>
          <td>(</td>
          <td class="paramtype">Node_SP&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CardinalDir&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node_SP&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CardinalDir&#160;</td>
          <td class="paramname"><em>d1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the minimal bend sequences for a <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The left anchor <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> of the <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d0</td><td>The CardinalDir in which the chain departs from <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td>The right anchor <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> of the <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d1</td><td>The CardinalDir in which the chain enters <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> Z (i.e. the CardinalDir from the last <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> of the <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a> toward the right anchor <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors of LinkShapes, giving all possible minimal bend sequences for this <a class="el" href="classdialect_1_1Chain.html" title="A Chain is a sequence of degree-2 Nodes, possibly forming a cycle. ">Chain</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does work correctly even for the case of a chain in which the left and right anchor nodes are the same (as, e.g., in a figure-8 network). </dd></dl>

<p class="reference">References <a class="el" href="namespacedialect.html#aee3a4f45528895913df2c82515700332">minimalBendSeqs</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Chain.html#a307a5e83c5d3e125c1b2483652732935">dialect::Chain::computePossibleBendSequences()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_ab13e7be712ac2f35c54fcc9e338d7902_icgraph.png" border="0" usemap="#namespacedialect_ab13e7be712ac2f35c54fcc9e338d7902_icgraph" alt=""/></div>
<map name="namespacedialect_ab13e7be712ac2f35c54fcc9e338d7902_icgraph" id="namespacedialect_ab13e7be712ac2f35c54fcc9e338d7902_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1Chain.html#a307a5e83c5d3e125c1b2483652732935" title="Compute the possible bend sequences that this chain could have. " alt="" coords="268,5,480,47"/>
<area shape="rect" id="node3" href="classdialect_1_1Chain.html#a78f0ee5307493976251e723e47ad0664" title="Give this chain an orthogonal configuration best fitting its present geometric shape. " alt="" coords="528,5,701,47"/>
</map>
</div>

</div>
</div>
<a id="afbe70f9004b1b9e78730273e67aa1d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe70f9004b1b9e78730273e67aa1d76">&#9670;&nbsp;</a></span>lookupQuadActions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; dialect::lookupQuadActions </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up legal quad actions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>= 0, 1, or 2, indicating whether there are 0, 1, or &gt;= 2 nodes in the first quadrant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>like p, only for the second quadrant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>like p, only for the third quadrant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>like p, only for the fourth quadrant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>binary coded representation of which semiaxes are to be used: 1's bit: 1 if EAST is to be used; else 0 2's bit: 1 if SOUTH is to be used; else 0 4's bit: 1 if WEST is to be used; else 0 8's bit: 1 if NORTH is to be used; else 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of strings, naming the legal quad actions </dd></dl>

<p class="reference">Referenced by <a class="el" href="structdialect_1_1Arrangement.html#ad226edce8ab3ae9c6ad7ead82eae4913">dialect::Arrangement::computeNAssignments()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_afbe70f9004b1b9e78730273e67aa1d76_icgraph.png" border="0" usemap="#namespacedialect_afbe70f9004b1b9e78730273e67aa1d76_icgraph" alt=""/></div>
<map name="namespacedialect_afbe70f9004b1b9e78730273e67aa1d76_icgraph" id="namespacedialect_afbe70f9004b1b9e78730273e67aa1d76_icgraph">
<area shape="rect" id="node2" href="structdialect_1_1Arrangement.html#ad226edce8ab3ae9c6ad7ead82eae4913" title="Compute all possible Assignments in which precisely N semiaxes are occupied, sorted by ascending cost..." alt="" coords="237,5,404,47"/>
<area shape="rect" id="node3" href="structdialect_1_1Arrangement.html#a973a28db1c16a09e5f6367687d5d2360" title="Compute all possible Assignments. " alt="" coords="452,5,624,47"/>
</map>
</div>

</div>
</div>
<a id="ad2ef85dafcc63a44823c914a5d54a425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ef85dafcc63a44823c914a5d54a425">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; dialect::partition </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(T)&gt;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition a vector of items according to a key value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">items</td><td>The vector of objects of type T that are to be partitioned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A function returning a floating point key value on objects of type T. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>If positive, put items into the same part provided their key is within tolerance of a running average key value for that part.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As a by-product, each part will be sorted in ascending order according to the given key function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors of objects of type T. </dd></dl>

</div>
</div>
<a id="a29b1d1583bf8668dde5e0252a2205eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b1d1583bf8668dde5e0252a2205eb1">&#9670;&nbsp;</a></span>peel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Trees dialect::peel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdialect_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the "peeling" process, in which the exterior trees are removed from the given <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>. </p>
<dl class="section note"><dt>Note</dt><dd>See Abello, James, Frank Van Ham, and Neeraj Krishnan. "Ask-graphview: A large scale graph visualization system." IEEE transactions on visualization and computer graphics 12 no. 5 (2006): 669-676.</dd>
<dd>
The given <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> is modiifed in place. It will be pared down to its own /core/ &ndash; i.e. all that remains after the trees have been peeled away.</dd></dl>
<p>Each tree includes a root node which is a copy of a node that remains in the core.</p>
<p>The underlying Graphs of the created Trees consist of PeeledNodes.</p>
<p>In the case that the given <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> is itself a tree, the remaining core will consist only of the tree's root node. Meanwhile the one Tree will be a copy of the entire original graph.</p>
<dl class="section return"><dt>Returns</dt><dd>The trees. </dd></dl>

<p class="reference">References <a class="el" href="classdialect_1_1Graph.html#a0adf4a0dc63a42b8196f3864d1d31e04">dialect::Graph::getNode()</a>, <a class="el" href="namespacedialect.html#a348cb1a0dfe6202d4ff711029a4ccf8e">identifyRootNode()</a>, <a class="el" href="classdialect_1_1Graph.html#ac4e10d13edd049dd2da80ea986b76fe9">dialect::Graph::isEmpty()</a>, <a class="el" href="namespacedialect.html#a7e4dc6aea10cd3c086f57c1be3960aeb">makeStemsFromLeaves()</a>, <a class="el" href="structdialect_1_1NodeBuckets.html#a7cba81f7da5c12fe1cad7c3b5173e556">dialect::NodeBuckets::severNodes()</a>, and <a class="el" href="structdialect_1_1NodeBuckets.html#a1058d0a33849b95a75ea5ee17ba979a4">dialect::NodeBuckets::takeLeaves()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76">doHOLA()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_cgraph.png" border="0" usemap="#namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_cgraph" alt=""/></div>
<map name="namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_cgraph" id="namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1Graph.html#a0adf4a0dc63a42b8196f3864d1d31e04" title="Look up a Node by ID. " alt="" coords="429,6,591,33"/>
<area shape="rect" id="node3" href="namespacedialect.html#a348cb1a0dfe6202d4ff711029a4ccf8e" title="Mark as &quot;root&quot; the PeeledNode having largest serial number. " alt="" coords="167,57,338,83"/>
<area shape="rect" id="node7" href="classdialect_1_1Graph.html#ac4e10d13edd049dd2da80ea986b76fe9" title="Say whether the Graph is empty, meaning that it has no Nodes. " alt="" coords="173,107,333,134"/>
<area shape="rect" id="node8" href="namespacedialect.html#a7e4dc6aea10cd3c086f57c1be3960aeb" title="Make a Stem object to represent each leaf. " alt="" coords="147,158,359,185"/>
<area shape="rect" id="node9" href="structdialect_1_1NodeBuckets.html#a7cba81f7da5c12fe1cad7c3b5173e556" title="Sever the given Nodes from our Graph. " alt="" coords="179,209,326,251"/>
<area shape="rect" id="node17" href="structdialect_1_1NodeBuckets.html#a1058d0a33849b95a75ea5ee17ba979a4" title="Return a copy of the bucket of leaves, and clear the latter. " alt="" coords="179,275,326,316"/>
<area shape="rect" id="node4" href="classdialect_1_1Graph.html#a5467080616423cac88b67242aedf0949" title="Read&#45;only access to this Graph&#39;s lookup map for Nodes by their ID. " alt="" coords="407,57,613,83"/>
<area shape="rect" id="node5" href="classdialect_1_1Node.html#a5463ea8526de6f00794156ae79f8226b" title="Say whether this Node is a root. This is useful when working with trees, and can be safely ignored wh..." alt="" coords="428,107,592,134"/>
<area shape="rect" id="node6" href="classdialect_1_1Node.html#ac9a5e3dbde4ca97e31486de74305f101" title="Check whether this Node has been marked as being a root. This is useful when working with trees..." alt="" coords="689,107,834,134"/>
<area shape="rect" id="node10" href="classdialect_1_1Graph.html#ad6434fe1d4f4fce48f5cd88bb943606c" title="Like severNode but also returns a vector of all Nodes that were neighbours before severing..." alt="" coords="421,159,599,200"/>
<area shape="rect" id="node15" href="structdialect_1_1NodeBuckets.html#a39f69438d390511f0a13edab602adcad" title="Move a node from one bucket to another. " alt="" coords="437,224,583,265"/>
<area shape="rect" id="node16" href="classdialect_1_1Graph.html#a6e23356b35518e9fd3ca93e3b6dd555a" title="Remove several Nodes from this Graph. " alt="" coords="412,290,608,317"/>
<area shape="rect" id="node11" href="classdialect_1_1Node.html#ab82a623cf2c0d97bfb3206b1b5d656f3" title="Read&#45;only access to this Node&#39;s lookup map for Edges by their ID. " alt="" coords="661,162,861,189"/>
<area shape="rect" id="node12" href="classdialect_1_1Graph.html#a86f8762c5ddfdad4c934285da5bd4933" title="Sever an Edge in this Graph. " alt="" coords="673,213,849,239"/>
<area shape="rect" id="node13" href="classdialect_1_1Edge.html#a04fbe3f536a380fc6d70bcb09728ca08" title="&quot;Sever&quot; this Edge, i.e. remove it from the Nodes to which it is attached. " alt="" coords="909,187,1048,214"/>
<area shape="rect" id="node14" href="classdialect_1_1Edge.html#ab3e603f70b854af7f69b12bcb7a06de4" title="Access the unique ID of this instance. " alt="" coords="920,238,1037,265"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_icgraph.png" border="0" usemap="#namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_icgraph" alt=""/></div>
<map name="namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_icgraph" id="namespacedialect_a29b1d1583bf8668dde5e0252a2205eb1_icgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76" title="Apply the HOLA layout algorithm to the given Graph. See Steve Kieffer, Tim Dwyer, Kim Marriott..." alt="" coords="147,5,265,32"/>
<area shape="rect" id="node3" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a" title="Convenience function to do HOLA layout with default options. " alt="" coords="313,5,432,32"/>
</map>
</div>

</div>
</div>
<a id="aaed146a04dc4b872386c2c407e05c3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed146a04dc4b872386c2c407e05c3ce">&#9670;&nbsp;</a></span>shapeOfLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a> dialect::shapeOfLink </td>
          <td>(</td>
          <td class="paramtype">Node_SP&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the LinkShape for a given <a class="el" href="classdialect_1_1Node.html" title="The Node class represents nodes in a graph. ">Node</a> of degree 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">link</td><td>The link whose shape is to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The LinkShape for the given node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Runtime</td><td>error if the given node is not of degree 2. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Chain.html#a8ed76f7de22ef8dfe4dbccf8a66bd9a3">dialect::Chain::Chain()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_aaed146a04dc4b872386c2c407e05c3ce_icgraph.png" border="0" usemap="#namespacedialect_aaed146a04dc4b872386c2c407e05c3ce_icgraph" alt=""/></div>
<map name="namespacedialect_aaed146a04dc4b872386c2c407e05c3ce_icgraph" id="namespacedialect_aaed146a04dc4b872386c2c407e05c3ce_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1Chain.html#a8ed76f7de22ef8dfe4dbccf8a66bd9a3" title="Standard constructor. " alt="" coords="196,5,341,32"/>
</map>
</div>

</div>
</div>
<a id="a7fdbc3f53251706e91936da1109bb644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdbc3f53251706e91936da1109bb644">&#9670;&nbsp;</a></span>string_format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string dialect::string_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String formatting. </p>
<dl class="section note"><dt>Note</dt><dd>Thanks to: <a href="https://stackoverflow.com/a/26221725">https://stackoverflow.com/a/26221725</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76">doHOLA()</a>, <a class="el" href="classdialect_1_1OrthoHubLayout.html#a0b9a6aa806f4ccf26b448aa67d7fed95">dialect::OrthoHubLayout::layout()</a>, <a class="el" href="namespacedialect.html#a9d325ef46ea3385428712f16fedf71ef">reattachTrees()</a>, <a class="el" href="structdialect_1_1BoundingBox.html#a4ac935fbf923030a33010944938f2403">dialect::BoundingBox::repr()</a>, <a class="el" href="classdialect_1_1LeaflessOrthoRouter.html#af58e911020f19a144303fc01e5b8c35e">dialect::LeaflessOrthoRouter::route()</a>, <a class="el" href="structdialect_1_1Assignment.html#a6321bce63ba1e9fb4ea424547117d7ed">dialect::Assignment::toString()</a>, <a class="el" href="classdialect_1_1Edge.html#a113033b926234142169038954fd4c2e2">dialect::Edge::writePolylineConnectorData()</a>, <a class="el" href="classdialect_1_1Edge.html#a57696e5f3cb8569a921382f44b7a4d52">dialect::Edge::writeRoundedOrthoConnectorData()</a>, <a class="el" href="classdialect_1_1Graph.html#abbb7c275cbba6760f40718dbcf265ea7">dialect::Graph::writeSvg()</a>, and <a class="el" href="classdialect_1_1Node.html#ace545cb25ccee1206296695edaf0af9b">dialect::Node::writeSvg()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacedialect_a7fdbc3f53251706e91936da1109bb644_icgraph.png" border="0" usemap="#namespacedialect_a7fdbc3f53251706e91936da1109bb644_icgraph" alt=""/></div>
<map name="namespacedialect_a7fdbc3f53251706e91936da1109bb644_icgraph" id="namespacedialect_a7fdbc3f53251706e91936da1109bb644_icgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76" title="Apply the HOLA layout algorithm to the given Graph. See Steve Kieffer, Tim Dwyer, Kim Marriott..." alt="" coords="457,78,575,105"/>
<area shape="rect" id="node4" href="classdialect_1_1OrthoHubLayout.html#a0b9a6aa806f4ccf26b448aa67d7fed95" title="Try to orthogonalise hubs. " alt="" coords="211,41,377,83"/>
<area shape="rect" id="node5" href="namespacedialect.html#a9d325ef46ea3385428712f16fedf71ef" title="Given a planar orthogonal core, and the corresponding Trees (as resulting from the peeling process)..." alt="" coords="219,107,369,134"/>
<area shape="rect" id="node6" href="structdialect_1_1BoundingBox.html#a4ac935fbf923030a33010944938f2403" title="Write a simple representation of the bounding box. " alt="" coords="221,159,367,200"/>
<area shape="rect" id="node7" href="classdialect_1_1LeaflessOrthoRouter.html#af58e911020f19a144303fc01e5b8c35e" title="Do the routing. " alt="" coords="199,224,389,265"/>
<area shape="rect" id="node8" href="structdialect_1_1Assignment.html#a6321bce63ba1e9fb4ea424547117d7ed" title="Write a string representation, listing the id of the Nbr assigned to each semiaxis. For example if Nbrs 3, 7, 8 are assigned to semiaxes E, S, N resp., represent this as &quot;3 7 &#45; 8&quot;. " alt="" coords="225,289,363,331"/>
<area shape="rect" id="node9" href="classdialect_1_1Edge.html#a113033b926234142169038954fd4c2e2" title="Write the data for a polyline SVG path for this Edge&#39;s connector route. " alt="" coords="203,355,385,396"/>
<area shape="rect" id="node11" href="classdialect_1_1Edge.html#a57696e5f3cb8569a921382f44b7a4d52" title="Write the data for an orthogonal SVG path for this Edge&#39;s connector route, using rounded bends..." alt="" coords="199,420,389,461"/>
<area shape="rect" id="node12" href="classdialect_1_1Graph.html#abbb7c275cbba6760f40718dbcf265ea7" title="Write SVG to represent this Graph. " alt="" coords="212,486,376,513"/>
<area shape="rect" id="node13" href="classdialect_1_1Node.html#ace545cb25ccee1206296695edaf0af9b" title="Write SVG to represent this Node. " alt="" coords="215,537,373,563"/>
<area shape="rect" id="node3" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a" title="Convenience function to do HOLA layout with default options. " alt="" coords="643,78,761,105"/>
<area shape="rect" id="node10" href="classdialect_1_1Edge.html#ae1a8c072d1df6f08766cf99542f76159" title="Write SVG to represent this Edge. " alt="" coords="437,394,595,421"/>
</map>
</div>

</div>
</div>
<a id="a283777bcbb68f6dbdeb06222a9ad2fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283777bcbb68f6dbdeb06222a9ad2fa3">&#9670;&nbsp;</a></span>writeStringToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::writeStringToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a string to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the string to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>full filesystem path to the file to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa2a3a7bf46544f6dd744c452a4bca7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a3a7bf46544f6dd744c452a4bca7c5">&#9670;&nbsp;</a></span>applyBendToDir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a>, map&lt; CardinalDir, CardinalDir &gt; &gt; dialect::applyBendToDir</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">    {LinkShape::TLC, { {CardinalDir::NORTH, CardinalDir::EAST}, {CardinalDir::WEST, CardinalDir::SOUTH} }},</div><div class="line">    {LinkShape::TRC, { {CardinalDir::NORTH, CardinalDir::WEST}, {CardinalDir::EAST, CardinalDir::SOUTH} }},</div><div class="line">    {LinkShape::BRC, { {CardinalDir::SOUTH, CardinalDir::WEST}, {CardinalDir::EAST, CardinalDir::NORTH} }},</div><div class="line">    {LinkShape::BLC, { {CardinalDir::SOUTH, CardinalDir::EAST}, {CardinalDir::WEST, CardinalDir::NORTH} }}</div><div class="line">}</div></div><!-- fragment --><p>Lookup table: Given one of the four bent LinkShapes b, and a CardinalDir d, return the CardinalDir you would be going if you came into bend b going in direction d, and then followed the bend. </p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Chain.html#a0560d4821db583682c3842ad21469804">dialect::Chain::writeConfigSeq()</a>.</p>

</div>
</div>
<a id="a9609206857646fa04632aef75676b1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9609206857646fa04632aef75676b1ea">&#9670;&nbsp;</a></span>cwIncomingDirForBend</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a>, CardinalDir &gt; dialect::cwIncomingDirForBend</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">    {LinkShape::TLC, CardinalDir::NORTH},</div><div class="line">    {LinkShape::TRC, CardinalDir::EAST},</div><div class="line">    {LinkShape::BRC, CardinalDir::SOUTH},</div><div class="line">    {LinkShape::BLC, CardinalDir::WEST}</div><div class="line">}</div></div><!-- fragment --><p>Lookup table: For any of the four bent LinkShapes, return its clockwise incoming CardinalDir. In other words, if you were going clockwise around a box, which direction would you be going when you entered this bend? </p>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1Chain.html#a0560d4821db583682c3842ad21469804">dialect::Chain::writeConfigSeq()</a>.</p>

</div>
</div>
<a id="aee3a4f45528895913df2c82515700332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3a4f45528895913df2c82515700332">&#9670;&nbsp;</a></span>minimalBendSeqs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const map&lt; CompassDir, map&lt; CardinalDir, map&lt; CardinalDir, vector&lt; vector&lt; <a class="el" href="namespacedialect.html#aeffe119eae768555a5403af3e03efd44">LinkShape</a> &gt; &gt; &gt; &gt; &gt; dialect::minimalBendSeqs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup table: Suppose you have a chain starting at node A and ending at node Z. Let c be the CompassDir from Z to A (which will be cardinal if A and Z are aligned, else ordinal). Suppose as we traverse the chain from A toward Z we must depart A going in CardinalDir d0, and must enter Z going in CardinalDir d1. Then by looking up (c, d0, d1) in this table, we get a vector of vectors of LinkShapes, giving all possible minimal bend sequences for this chain.</p>
<p>Note: Whereas d0 gives both the direction from which we depart node A AND the side of A from which we depart, d1 is the direction we travel as we enter node Z (and therefore is the OPPOSITE of the side of Z at which we enter). For example d1 = EAST means we are traveling east as we enter node Z (but we enter it on its west side). </p>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#ab13e7be712ac2f35c54fcc9e338d7902">lookupMinimalBendSeqs()</a>.</p>

</div>
</div>
<a id="a429978c394e78f7e95f6ab9a3bc1e1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429978c394e78f7e95f6ab9a3bc1e1fe">&#9670;&nbsp;</a></span>SEMIAXIS_SETS_BY_CARDINALITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned&gt; dialect::SEMIAXIS_SETS_BY_CARDINALITY[5]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {0},</div><div class="line">    {1, 2, 4, 8},</div><div class="line">    {3, 5, 9, 6, 10, 12},</div><div class="line">    {14, 13, 11, 7},</div><div class="line">    {15}</div><div class="line">}</div></div><!-- fragment --><p>Using the binary coding for vacant semiaxes described in the doctext for the lookupQuadActions function, each integer 0, 1, ..., 15 describes a subset of the set of all semiaxes. It is useful to have these subset codes sorted by cardinality of the set. </p>

<p class="reference">Referenced by <a class="el" href="structdialect_1_1Arrangement.html#ad226edce8ab3ae9c6ad7ead82eae4913">dialect::Arrangement::computeNAssignments()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 17 2019 14:55:41 for Adaptagrams by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
