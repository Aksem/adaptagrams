<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptagrams: dialect::ACALayout Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptagrams
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedialect.html">dialect</a></li><li class="navelem"><a class="el" href="classdialect_1_1ACALayout.html">ACALayout</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdialect_1_1ACALayout-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dialect::ACALayout Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the Adaptive Constrained Alignment (ACA) algorithm.  
 <a href="classdialect_1_1ACALayout.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="aca_8h_source.html">aca.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dialect::ACALayout:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1ACALayout__coll__graph.png" border="0" usemap="#dialect_1_1ACALayout_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5cee9d383b844dc1f57e0e38ee7f161"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#ab5cee9d383b844dc1f57e0e38ee7f161">ACALayout</a> (const <a class="el" href="namespacevpsc.html#adc3cc05bc53422606216ab4b741fca90">vpsc::Rectangles</a> &amp;rs, const std::vector&lt; <a class="el" href="namespacecola.html#ade473937d660dcc8ec335279a1ae3d18">cola::Edge</a> &gt; &amp;es, <a class="el" href="namespacecola.html#a264085c472922afe01b3b9162541aaf0">cola::CompoundConstraints</a> &amp;ccs, const double idealLength, const <a class="el" href="namespacecola.html#af3a5eb5199d2eeaff290f9bcf6690f7a">cola::EdgeLengths</a> &amp;eLengths=cola::StandardEdgeLengths, <a class="el" href="classcola_1_1TestConvergence.html">cola::TestConvergence</a> *doneTest=nullptr, <a class="el" href="classcola_1_1PreIteration.html">cola::PreIteration</a> *preIteration=nullptr)</td></tr>
<tr class="memdesc:ab5cee9d383b844dc1f57e0e38ee7f161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an adaptive constrained alignment layout instance.  <a href="#ab5cee9d383b844dc1f57e0e38ee7f161">More...</a><br /></td></tr>
<tr class="separator:ab5cee9d383b844dc1f57e0e38ee7f161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d829fd1e9b7f42a51d26c757257f22a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a2d829fd1e9b7f42a51d26c757257f22a">ACALayout</a> (std::shared_ptr&lt; <a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &gt; G)</td></tr>
<tr class="memdesc:a2d829fd1e9b7f42a51d26c757257f22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="classdialect_1_1ACALayout.html" title="Implements the Adaptive Constrained Alignment (ACA) algorithm. ">ACALayout</a> based on a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>.  <a href="#a2d829fd1e9b7f42a51d26c757257f22a">More...</a><br /></td></tr>
<tr class="separator:a2d829fd1e9b7f42a51d26c757257f22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc4364e821983142e55e978e33e29a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a0fc4364e821983142e55e978e33e29a2">createAlignments</a> (void)</td></tr>
<tr class="memdesc:a0fc4364e821983142e55e978e33e29a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates alignments.  <a href="#a0fc4364e821983142e55e978e33e29a2">More...</a><br /></td></tr>
<tr class="separator:a0fc4364e821983142e55e978e33e29a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e450213150f377f0289d4f06345c008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a5e450213150f377f0289d4f06345c008">createOneAlignment</a> (void)</td></tr>
<tr class="memdesc:a5e450213150f377f0289d4f06345c008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates one alignment.  <a href="#a5e450213150f377f0289d4f06345c008">More...</a><br /></td></tr>
<tr class="separator:a5e450213150f377f0289d4f06345c008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64d1f3c84dcd313ab48e57f4788b026"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#ad64d1f3c84dcd313ab48e57f4788b026">applyOAsAllOrNothing</a> (OrderedAlignments oas)</td></tr>
<tr class="memdesc:ad64d1f3c84dcd313ab48e57f4788b026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all the requested alignments, or none if any is infeasible.  <a href="#ad64d1f3c84dcd313ab48e57f4788b026">More...</a><br /></td></tr>
<tr class="separator:ad64d1f3c84dcd313ab48e57f4788b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04e719586c594d5327a816f6fccc40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#ab04e719586c594d5327a816f6fccc40d">layout</a> (void)</td></tr>
<tr class="memdesc:ab04e719586c594d5327a816f6fccc40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an initial stress-minimising layout, and then create alignments.  <a href="#ab04e719586c594d5327a816f6fccc40d">More...</a><br /></td></tr>
<tr class="separator:ab04e719586c594d5327a816f6fccc40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7253f7df41f52ff5bbb045a65ca9ebc2"><td class="memItemLeft" align="right" valign="top"><a id="a7253f7df41f52ff5bbb045a65ca9ebc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a7253f7df41f52ff5bbb045a65ca9ebc2">removeOverlaps</a> (void)</td></tr>
<tr class="memdesc:a7253f7df41f52ff5bbb045a65ca9ebc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an FD layout with overlap prevention, then stop. <br /></td></tr>
<tr class="separator:a7253f7df41f52ff5bbb045a65ca9ebc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bf5a09101160fdd89d14b823f32534"><td class="memItemLeft" align="right" valign="top"><a id="a29bf5a09101160fdd89d14b823f32534"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a29bf5a09101160fdd89d14b823f32534">layoutWithCurrentConstraints</a> (void)</td></tr>
<tr class="memdesc:a29bf5a09101160fdd89d14b823f32534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run layout with current constraints, and with or without overlap prevention, as per the current settings. <br /></td></tr>
<tr class="separator:a29bf5a09101160fdd89d14b823f32534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8987f21eba0008c7f43ecbbc6b961fd"><td class="memItemLeft" align="right" valign="top"><a id="ad8987f21eba0008c7f43ecbbc6b961fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#ad8987f21eba0008c7f43ecbbc6b961fd">updateGraph</a> (void)</td></tr>
<tr class="memdesc:ad8987f21eba0008c7f43ecbbc6b961fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For forward compatibility (i.e. with Graphs), we offer a convenience method to update the <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> (when we have one) with the positions and constraints chosen by this object. <br /></td></tr>
<tr class="separator:ad8987f21eba0008c7f43ecbbc6b961fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9467554d9931aee36e5825d4a574fb"><td class="memItemLeft" align="right" valign="top"><a id="afb9467554d9931aee36e5825d4a574fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#afb9467554d9931aee36e5825d4a574fb">updateSepMatrix</a> (void)</td></tr>
<tr class="memdesc:afb9467554d9931aee36e5825d4a574fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the SepMatrix of the <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> on which this <a class="el" href="classdialect_1_1ACALayout.html" title="Implements the Adaptive Constrained Alignment (ACA) algorithm. ">ACALayout</a> was built (if any). <br /></td></tr>
<tr class="separator:afb9467554d9931aee36e5825d4a574fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135334e9f39476e4ffd8feb6b539cf40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a135334e9f39476e4ffd8feb6b539cf40">updateSepMatrix</a> (SepMatrix &amp;M, const std::map&lt; size_t, id_type &gt; &amp;ix2id)</td></tr>
<tr class="memdesc:a135334e9f39476e4ffd8feb6b539cf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a given SepMatrix with all the ordered alignment constraints generated by this ACA layout.  <a href="#a135334e9f39476e4ffd8feb6b539cf40">More...</a><br /></td></tr>
<tr class="separator:a135334e9f39476e4ffd8feb6b539cf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a5f4847f098068a638f4a8c4319394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a99a5f4847f098068a638f4a8c4319394">addBendPointPenalty</a> (bool b)</td></tr>
<tr class="memdesc:a99a5f4847f098068a638f4a8c4319394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control whether we avoid making bend points.  <a href="#a99a5f4847f098068a638f4a8c4319394">More...</a><br /></td></tr>
<tr class="separator:a99a5f4847f098068a638f4a8c4319394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff88a4c817ca523a2b636b4c820e405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a1ff88a4c817ca523a2b636b4c820e405">favourLongEdges</a> (bool b)</td></tr>
<tr class="memdesc:a1ff88a4c817ca523a2b636b4c820e405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefer long edges instead of ones that are close to aligned.  <a href="#a1ff88a4c817ca523a2b636b4c820e405">More...</a><br /></td></tr>
<tr class="separator:a1ff88a4c817ca523a2b636b4c820e405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1248174ca8d5d6c02077a1efa9515ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a1248174ca8d5d6c02077a1efa9515ab6">postponeLeaves</a> (bool b)</td></tr>
<tr class="memdesc:a1248174ca8d5d6c02077a1efa9515ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say whether alignment of leaf edges should be saved for last.  <a href="#a1248174ca8d5d6c02077a1efa9515ab6">More...</a><br /></td></tr>
<tr class="separator:a1248174ca8d5d6c02077a1efa9515ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4698c8d1939cbac283d2e393bf5db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#acd4698c8d1939cbac283d2e393bf5db3">useNonLeafDegree</a> (bool b)</td></tr>
<tr class="memdesc:acd4698c8d1939cbac283d2e393bf5db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say whether leaves should be counted when computing node degrees.  <a href="#acd4698c8d1939cbac283d2e393bf5db3">More...</a><br /></td></tr>
<tr class="separator:acd4698c8d1939cbac283d2e393bf5db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825786cbbabe7c555dade02777a1835e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a825786cbbabe7c555dade02777a1835e">allAtOnce</a> (bool b)</td></tr>
<tr class="memdesc:a825786cbbabe7c555dade02777a1835e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say whether alignment choices should alternate with stress minimisation steps.  <a href="#a825786cbbabe7c555dade02777a1835e">More...</a><br /></td></tr>
<tr class="separator:a825786cbbabe7c555dade02777a1835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f6eb0bcd5ca97829d0b36a7b680a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#aa06f6eb0bcd5ca97829d0b36a7b680a4">aggressiveOrdering</a> (bool b)</td></tr>
<tr class="memdesc:aa06f6eb0bcd5ca97829d0b36a7b680a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say whether to consider changing orthogonal ordering of nodes.  <a href="#aa06f6eb0bcd5ca97829d0b36a7b680a4">More...</a><br /></td></tr>
<tr class="separator:aa06f6eb0bcd5ca97829d0b36a7b680a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc6f77f551875f4441fa0e53591e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#adbbc6f77f551875f4441fa0e53591e35">setAvoidNodeOverlaps</a> (bool avoidOverlaps)</td></tr>
<tr class="memdesc:adbbc6f77f551875f4441fa0e53591e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether non-overlap constraints should be automatically generated between all nodes.  <a href="#adbbc6f77f551875f4441fa0e53591e35">More...</a><br /></td></tr>
<tr class="separator:adbbc6f77f551875f4441fa0e53591e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d713814eca5c1754795fd46f01165d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a4d713814eca5c1754795fd46f01165d0">ignoreEdges</a> (std::vector&lt; bool &gt; ignore)</td></tr>
<tr class="memdesc:a4d713814eca5c1754795fd46f01165d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that certain edges are never to be aligned.  <a href="#a4d713814eca5c1754795fd46f01165d0">More...</a><br /></td></tr>
<tr class="separator:a4d713814eca5c1754795fd46f01165d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2706ef2c217504c564ca49b8c7f8e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a9c2706ef2c217504c564ca49b8c7f8e8">ignoreNodesForOPWithOffsets</a> (std::vector&lt; bool &gt; ignore)</td></tr>
<tr class="memdesc:a9c2706ef2c217504c564ca49b8c7f8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say that certain nodes may be crossed by edges.  <a href="#a9c2706ef2c217504c564ca49b8c7f8e8">More...</a><br /></td></tr>
<tr class="separator:a9c2706ef2c217504c564ca49b8c7f8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7eaf681ec7068bb3cdf9752e9bc486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#add7eaf681ec7068bb3cdf9752e9bc486">setNodeAliases</a> (std::map&lt; int, int &gt; aliases)</td></tr>
<tr class="memdesc:add7eaf681ec7068bb3cdf9752e9bc486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set certain nodes to be used in place of others.  <a href="#add7eaf681ec7068bb3cdf9752e9bc486">More...</a><br /></td></tr>
<tr class="separator:add7eaf681ec7068bb3cdf9752e9bc486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa276a0d9dbb2d0cd8c66baf0263e3369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#aa276a0d9dbb2d0cd8c66baf0263e3369">setAlignmentOffsetsForCompassDirection</a> (ACASepFlag sf, EdgeOffsets offsets)</td></tr>
<tr class="memdesc:aa276a0d9dbb2d0cd8c66baf0263e3369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say how to offset nodes when edges are aligned in a certain direction.  <a href="#aa276a0d9dbb2d0cd8c66baf0263e3369">More...</a><br /></td></tr>
<tr class="separator:aa276a0d9dbb2d0cd8c66baf0263e3369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7d132acb8ce9a10b84d9b8357d5251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#aae7d132acb8ce9a10b84d9b8357d5251">setAllowedDirections</a> (ACASepFlags seps)</td></tr>
<tr class="memdesc:aae7d132acb8ce9a10b84d9b8357d5251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say which separations are allowed for the source and target of each edge.  <a href="#aae7d132acb8ce9a10b84d9b8357d5251">More...</a><br /></td></tr>
<tr class="separator:aae7d132acb8ce9a10b84d9b8357d5251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5e9fba7467a78e7da0660f78f2dcb4"><td class="memItemLeft" align="right" valign="top"><a id="a4b5e9fba7467a78e7da0660f78f2dcb4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a4b5e9fba7467a78e7da0660f78f2dcb4">setClusterHierarchy</a> (<a class="el" href="classcola_1_1RootCluster.html">cola::RootCluster</a> *rc)</td></tr>
<tr class="memdesc:a4b5e9fba7467a78e7da0660f78f2dcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the cluster hierarchy of the underlying FDLayout. <br /></td></tr>
<tr class="separator:a4b5e9fba7467a78e7da0660f78f2dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d46a45479063e1b6ab62f97ae1e207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#a55d46a45479063e1b6ab62f97ae1e207">edgeIsAligned</a> (int j) const</td></tr>
<tr class="memdesc:a55d46a45479063e1b6ab62f97ae1e207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an edge is aligned.  <a href="#a55d46a45479063e1b6ab62f97ae1e207">More...</a><br /></td></tr>
<tr class="separator:a55d46a45479063e1b6ab62f97ae1e207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ecad33afe7b89c143e5854d5f5f009"><td class="memItemLeft" align="right" valign="top"><a id="ae8ecad33afe7b89c143e5854d5f5f009"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdialect_1_1ACALayout.html#ae8ecad33afe7b89c143e5854d5f5f009">addGroupOfNonOverlapExemptRectangles</a> (std::vector&lt; unsigned &gt; rs)</td></tr>
<tr class="memdesc:ae8ecad33afe7b89c143e5854d5f5f009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop non-overlap constraints from being generated between certain nodes. <br /></td></tr>
<tr class="separator:ae8ecad33afe7b89c143e5854d5f5f009"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the Adaptive Constrained Alignment (ACA) algorithm. </p>
<p>See Steve Kieffer, Tim Dwyer, Kim Marriott, and Michael Wybrow. "Incremental grid-like layout using soft and hard constraints." In <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> Drawing 2013, pp. 448-459. Springer International Publishing, 2013. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab5cee9d383b844dc1f57e0e38ee7f161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cee9d383b844dc1f57e0e38ee7f161">&#9670;&nbsp;</a></span>ACALayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dialect::ACALayout::ACALayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevpsc.html#adc3cc05bc53422606216ab4b741fca90">vpsc::Rectangles</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacecola.html#ade473937d660dcc8ec335279a1ae3d18">cola::Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>es</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecola.html#a264085c472922afe01b3b9162541aaf0">cola::CompoundConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>ccs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>idealLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecola.html#af3a5eb5199d2eeaff290f9bcf6690f7a">cola::EdgeLengths</a> &amp;&#160;</td>
          <td class="paramname"><em>eLengths</em> = <code>cola::StandardEdgeLengths</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcola_1_1TestConvergence.html">cola::TestConvergence</a> *&#160;</td>
          <td class="paramname"><em>doneTest</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcola_1_1PreIteration.html">cola::PreIteration</a> *&#160;</td>
          <td class="paramname"><em>preIteration</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an adaptive constrained alignment layout instance. </p>
<p>Parameters are the same as for the ConstrainedFDLayout constructor, with the addition of a vector of constraints passed by reference.</p>
<p>If the vector of constraints is non-empty, these constraints will be applied throughout the ACA process, and the new constraints created by ACA will not conflict with any of these.</p>
<p>In any case, the new constraints generated by ACA are added to this vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rs</td><td>The bounding boxes of the nodes at their initial positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">es</td><td>The edges, given as simple pairs of indices (i, j) into the rectangle vector rs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccs</td><td>Vector of any pre-existing constraints, and the place where new constraints created by ACA will be recorded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idealLength</td><td>The "ideal edge length" parameter for the stress function, i.e. the ideal separation between neighbouring nodes. If eLengths (see below) is specified, then this parameter becomes instead a scalar multiplier for the lengths given there. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preventOverlaps</td><td>Say whether non-overlap constraints should be generated for all rectangles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eLengths</td><td>Individual ideal lengths for edges. The actual ideal length used for the ith edge is idealLength*eLengths[i]. If eLengths is not passed, then just idealLength is used (as if eLengths[i] were equal to 1 for all i). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">done</td><td>A test of convergence operation called at the end of each iteration (optional). If not given, uses a default TestConvergence object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preIteration</td><td>An operation to be called before each iteration (optional). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d829fd1e9b7f42a51d26c757257f22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d829fd1e9b7f42a51d26c757257f22a">&#9670;&nbsp;</a></span>ACALayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dialect::ACALayout::ACALayout </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classdialect_1_1Graph.html">dialect::Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="classdialect_1_1ACALayout.html" title="Implements the Adaptive Constrained Alignment (ACA) algorithm. ">ACALayout</a> based on a <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td>the <a class="el" href="classdialect_1_1Graph.html" title="The Graph class represents graphs consisting of nodes and edges. ">Graph</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a99a5f4847f098068a638f4a8c4319394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a5f4847f098068a638f4a8c4319394">&#9670;&nbsp;</a></span>addBendPointPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::addBendPointPenalty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control whether we avoid making bend points. </p>
<p>We refer to a node of degree 2 as a "bend point" when one of its edges has been aligned horizontally and the other vertically.</p>
<p>The default value of addBendPointPenalty is true. In this case a penalty score is added when choosing the next alignment in order to postpone creating bend points until no other choices remain.</p>
<p>If set to false then there is no penalty score to postpone the creation of bend points.</p>
<p>When there is both bend point penalty and leaf penalty (see below), then bend points will be created before leaf edges are aligned. This can be reversed by altering the BP_PENALTY and LEAF_PENALTY constants. </p>

</div>
</div>
<a id="aa06f6eb0bcd5ca97829d0b36a7b680a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06f6eb0bcd5ca97829d0b36a7b680a4">&#9670;&nbsp;</a></span>aggressiveOrdering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::aggressiveOrdering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Say whether to consider changing orthogonal ordering of nodes. </p>
<p>The default value is false. In that case, consider a pair of nodes u, v where v currently lies to the southeast of u. Then when ACA considers aligning u and v it will only consider putting v east or south of u; it will not consider reversing their current ordering in either dimension.</p>
<p>In the same example, if you set aggressiveOrdering to true, then ACA will also consider putting v north and west of u.</p>
<p>In the exceptional case of a node v lying, say, precisely east of a node u despite not being constrained to that alignment, then ACA will consider placing v east, north, and south of u even with aggressiveOrdering set to false. (But it will consider west only with it set to true.) </p>

</div>
</div>
<a id="a825786cbbabe7c555dade02777a1835e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825786cbbabe7c555dade02777a1835e">&#9670;&nbsp;</a></span>allAtOnce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::allAtOnce </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Say whether alignment choices should alternate with stress minimisation steps. </p>
<p>The default value of allAtOnce is false. In this case, after each new alignment is chosen, stress is again minimised before choosing the next one.</p>
<p>If you set allAtOnce to true, then all the alignments will be chosen based on the initial layout, and then they will all be applied at once. </p>

</div>
</div>
<a id="ad64d1f3c84dcd313ab48e57f4788b026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64d1f3c84dcd313ab48e57f4788b026">&#9670;&nbsp;</a></span>applyOAsAllOrNothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dialect::ACALayout::applyOAsAllOrNothing </td>
          <td>(</td>
          <td class="paramtype">OrderedAlignments&#160;</td>
          <td class="paramname"><em>oas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates all the requested alignments, or none if any is infeasible. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all alignments are successfully applied, else false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classdialect_1_1OrthoHubLayout.html#a0b9a6aa806f4ccf26b448aa67d7fed95">dialect::OrthoHubLayout::layout()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1ACALayout_ad64d1f3c84dcd313ab48e57f4788b026_icgraph.png" border="0" usemap="#classdialect_1_1ACALayout_ad64d1f3c84dcd313ab48e57f4788b026_icgraph" alt=""/></div>
<map name="classdialect_1_1ACALayout_ad64d1f3c84dcd313ab48e57f4788b026_icgraph" id="classdialect_1_1ACALayout_ad64d1f3c84dcd313ab48e57f4788b026_icgraph">
<area shape="rect" id="node2" href="classdialect_1_1OrthoHubLayout.html#a0b9a6aa806f4ccf26b448aa67d7fed95" title="Try to orthogonalise hubs. " alt="" coords="216,5,381,47"/>
<area shape="rect" id="node3" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76" title="Apply the HOLA layout algorithm to the given Graph. See Steve Kieffer, Tim Dwyer, Kim Marriott..." alt="" coords="429,13,548,39"/>
<area shape="rect" id="node4" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a" title="Convenience function to do HOLA layout with default options. " alt="" coords="596,13,715,39"/>
</map>
</div>

</div>
</div>
<a id="a0fc4364e821983142e55e978e33e29a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc4364e821983142e55e978e33e29a2">&#9670;&nbsp;</a></span>createAlignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::createAlignments </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates alignments. </p>
<p>This is the main functionality of ACA. This function should be called on an existing layout in order to greedily align edges until any further alignments would create edge overlaps.</p>
<p>If the graph does not have an initial layout already, then the 'layout' function may be called instead. </p>

<p class="reference">Referenced by <a class="el" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76">dialect::doHOLA()</a>, and <a class="el" href="classdialect_1_1ACALayout.html#ab04e719586c594d5327a816f6fccc40d">layout()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1ACALayout_a0fc4364e821983142e55e978e33e29a2_icgraph.png" border="0" usemap="#classdialect_1_1ACALayout_a0fc4364e821983142e55e978e33e29a2_icgraph" alt=""/></div>
<map name="classdialect_1_1ACALayout_a0fc4364e821983142e55e978e33e29a2_icgraph" id="classdialect_1_1ACALayout_a0fc4364e821983142e55e978e33e29a2_icgraph">
<area shape="rect" id="node2" href="namespacedialect.html#a05ccc4c149e1b5902ec827bfabd3cf76" title="Apply the HOLA layout algorithm to the given Graph. See Steve Kieffer, Tim Dwyer, Kim Marriott..." alt="" coords="198,5,317,32"/>
<area shape="rect" id="node4" href="classdialect_1_1ACALayout.html#ab04e719586c594d5327a816f6fccc40d" title="Do an initial stress&#45;minimising layout, and then create alignments. " alt="" coords="189,57,325,98"/>
<area shape="rect" id="node3" href="namespacedialect.html#a24766038e1a9ccd99997ea31c42b432a" title="Convenience function to do HOLA layout with default options. " alt="" coords="373,5,492,32"/>
</map>
</div>

</div>
</div>
<a id="a5e450213150f377f0289d4f06345c008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e450213150f377f0289d4f06345c008">&#9670;&nbsp;</a></span>createOneAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dialect::ACALayout::createOneAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates one alignment. </p>
<p>Call this function instead of createAlignments in order to create just one alignment and then stop. The return value is true if and only if a new alignment was actually created.</p>
<p>Thus, repeatedly calling this function until it returns false achieves the exact same result as simply calling createAlignments. </p>

</div>
</div>
<a id="a55d46a45479063e1b6ab62f97ae1e207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d46a45479063e1b6ab62f97ae1e207">&#9670;&nbsp;</a></span>edgeIsAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dialect::ACALayout::edgeIsAligned </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an edge is aligned. </p>
<p>Pass the index of the edge. The returned boolean says whether ACA aligned this edge. </p>

</div>
</div>
<a id="a1ff88a4c817ca523a2b636b4c820e405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff88a4c817ca523a2b636b4c820e405">&#9670;&nbsp;</a></span>favourLongEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::favourLongEdges </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefer long edges instead of ones that are close to aligned. </p>
<p>This defaults to 'false', in which case ACA prefers to align edges that are almost aligned already. When set to 'true' it will instead choose the longest edges first. </p>

</div>
</div>
<a id="a4d713814eca5c1754795fd46f01165d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d713814eca5c1754795fd46f01165d0">&#9670;&nbsp;</a></span>ignoreEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::ignoreEdges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify that certain edges are never to be aligned. </p>
<p>The number of booleans must equal the number of edges in the graph. Entry j should be 'true' if you want edge j to be ignored (never aligned); 'false' otherwise. </p>

</div>
</div>
<a id="a9c2706ef2c217504c564ca49b8c7f8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2706ef2c217504c564ca49b8c7f8e8">&#9670;&nbsp;</a></span>ignoreNodesForOPWithOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::ignoreNodesForOPWithOffsets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Say that certain nodes may be crossed by edges. </p>
<p>When using the ACAOPWITHOFFSETS option, a potential alignment will /not/ be marked as creating an edge-node overlap if for all indices i such that the alignment would make an edge overlap node i, the ith entry in the vector passed to this function is true. </p>

</div>
</div>
<a id="ab04e719586c594d5327a816f6fccc40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04e719586c594d5327a816f6fccc40d">&#9670;&nbsp;</a></span>layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::layout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do an initial stress-minimising layout, and then create alignments. </p>
<p>This is a convenience function which first does a constrained force-directed layout of the given graph, and then calls the 'createAlignments' function. </p>

<p class="reference">References <a class="el" href="classdialect_1_1ACALayout.html#a0fc4364e821983142e55e978e33e29a2">createAlignments()</a>, and <a class="el" href="classdialect_1_1ACALayout.html#a29bf5a09101160fdd89d14b823f32534">layoutWithCurrentConstraints()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classdialect_1_1ACALayout_ab04e719586c594d5327a816f6fccc40d_cgraph.png" border="0" usemap="#classdialect_1_1ACALayout_ab04e719586c594d5327a816f6fccc40d_cgraph" alt=""/></div>
<map name="classdialect_1_1ACALayout_ab04e719586c594d5327a816f6fccc40d_cgraph" id="classdialect_1_1ACALayout_ab04e719586c594d5327a816f6fccc40d_cgraph">
<area shape="rect" id="node2" href="classdialect_1_1ACALayout.html#a0fc4364e821983142e55e978e33e29a2" title="Creates alignments. " alt="" coords="223,71,359,112"/>
<area shape="rect" id="node3" href="classdialect_1_1ACALayout.html#a29bf5a09101160fdd89d14b823f32534" title="Run layout with current constraints, and with or without overlap prevention, as per the current setti..." alt="" coords="189,136,393,177"/>
<area shape="rect" id="node4" href="classcola_1_1ConstrainedFDLayout.html#a9d88ae147adc1fb6631ba4dae5916042" title="Specifies whether non&#45;overlap constraints should be automatically generated between all nodes..." alt="" coords="455,5,639,47"/>
<area shape="rect" id="node5" href="classcola_1_1ConstrainedFDLayout.html#a594a0df207c598378e4b60edf8c642bb" title="Register to receive information about unsatisfiable constraints. " alt="" coords="443,71,650,112"/>
<area shape="rect" id="node6" href="classcola_1_1ConstrainedFDLayout.html#a394179b3591f1e708f73ffea85d633b1" title="Specify a set of compound constraints to apply to the layout. " alt="" coords="455,136,639,177"/>
<area shape="rect" id="node7" href="classcola_1_1ConstrainedFDLayout.html#af1e978ca8225a571cfb8c991e92f0abe" title="Specifies an optional hierarchy for clustering nodes. " alt="" coords="455,201,639,243"/>
<area shape="rect" id="node8" href="classcola_1_1ConstrainedFDLayout.html#a06eb591211419e216415a88477f7ab85" title="Implements the main layout loop, taking descent steps until stress is no&#45;longer significantly reduced..." alt="" coords="441,267,652,294"/>
</map>
</div>

</div>
</div>
<a id="a1248174ca8d5d6c02077a1efa9515ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1248174ca8d5d6c02077a1efa9515ab6">&#9670;&nbsp;</a></span>postponeLeaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::postponeLeaves </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Say whether alignment of leaf edges should be saved for last. </p>
<p>The default value is true. </p>

</div>
</div>
<a id="aa276a0d9dbb2d0cd8c66baf0263e3369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa276a0d9dbb2d0cd8c66baf0263e3369">&#9670;&nbsp;</a></span>setAlignmentOffsetsForCompassDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::setAlignmentOffsetsForCompassDirection </td>
          <td>(</td>
          <td class="paramtype">ACASepFlag&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOffsets&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Say how to offset nodes when edges are aligned in a certain direction. </p>
<p>The number of offsets must equal the number of edges in the graph. For any edge e=(s,t), let o=(ds,dt) be the corresponding offset. Then if ACA aligns edge e so that sf is the separation from s to t, then s will be offset from the alignment guideline by ds, and t by dt.</p>
<p>If you do not set any offsets then offsets of zero will be used. </p>

</div>
</div>
<a id="aae7d132acb8ce9a10b84d9b8357d5251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7d132acb8ce9a10b84d9b8357d5251">&#9670;&nbsp;</a></span>setAllowedDirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::setAllowedDirections </td>
          <td>(</td>
          <td class="paramtype">ACASepFlags&#160;</td>
          <td class="paramname"><em>seps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Say which separations are allowed for the source and target of each edge. </p>
<p>The number of separation flags must equal the number of edges in the graph. For any edge e=(s,t), let f be the corresponding flag. Then when ACA considers aligning edge e it will only consider the directions whose bits are set in f.</p>
<p>If you do not set allowed separations then all are considered to be allowed.</p>
<p>Note that if aggressiveOrdering is false then even if you set ACAALLSEP as allowed direction, still only the two "natural" directions will be tried. (See <a class="el" href="classdialect_1_1ACALayout.html#aa06f6eb0bcd5ca97829d0b36a7b680a4" title="Say whether to consider changing orthogonal ordering of nodes. ">aggressiveOrdering()</a>.) </p>

</div>
</div>
<a id="adbbc6f77f551875f4441fa0e53591e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbc6f77f551875f4441fa0e53591e35">&#9670;&nbsp;</a></span>setAvoidNodeOverlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::setAvoidNodeOverlaps </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoidOverlaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether non-overlap constraints should be automatically generated between all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">avoidOverlaps</td><td>New boolean value for this option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add7eaf681ec7068bb3cdf9752e9bc486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7eaf681ec7068bb3cdf9752e9bc486">&#9670;&nbsp;</a></span>setNodeAliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::setNodeAliases </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>aliases</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set certain nodes to be used in place of others. </p>
<p>Pass a map m. Then for each computation that involves a node u, we will check whether u is a key in m, and if so will use m(u) instead. </p>

</div>
</div>
<a id="a135334e9f39476e4ffd8feb6b539cf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135334e9f39476e4ffd8feb6b539cf40">&#9670;&nbsp;</a></span>updateSepMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::updateSepMatrix </td>
          <td>(</td>
          <td class="paramtype">SepMatrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; size_t, id_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>ix2id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a given SepMatrix with all the ordered alignment constraints generated by this ACA layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the SepMatrix to be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ix2id</td><td>a mapping from Rectangle indices back to the IDs of the Nodes they represent. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacedialect.html#a074c3a074f26cf4a8ff4a209d7d61e4fa45ac78bf3d4882ac520f4e7fb08d55c5">dialect::EAST</a>.</p>

</div>
</div>
<a id="acd4698c8d1939cbac283d2e393bf5db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4698c8d1939cbac283d2e393bf5db3">&#9670;&nbsp;</a></span>useNonLeafDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dialect::ACALayout::useNonLeafDegree </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Say whether leaves should be counted when computing node degrees. </p>
<p>The default value is true.</p>
<p>This setting matters only if addBendPointPenalty is set to true. In that case, if useNonLeafDegree is also true then the nodes identified as potential bend points will be those having exactly 2 /non-leaf/ neighbours.</p>
<p>When there is both leaf penalty and bend point penalty (see above), then bend points will be created before leaf edges are aligned. This can be reversed by altering the BP_PENALTY and LEAF_PENALTY constants. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libdialect/<a class="el" href="aca_8h_source.html">aca.h</a></li>
<li>libdialect/aca.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 17 2019 14:55:41 for Adaptagrams by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
